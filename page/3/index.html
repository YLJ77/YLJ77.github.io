
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>fire on the world!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="YLJ77">
    

    
    <meta name="description" content="学习总结与感悟">
<meta property="og:type" content="website">
<meta property="og:title" content="fire on the world!">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="fire on the world!">
<meta property="og:description" content="学习总结与感悟">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fire on the world!">
<meta name="twitter:description" content="学习总结与感悟">

    
    <link rel="alternative" href="/atom.xml" title="fire on the world!" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="fire on the world!" title="fire on the world!"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="fire on the world!">fire on the world!</a></h1>
				<h2 class="blog-motto">try to take over the world</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/表单脚本/" title="表单脚本" itemprop="url">表单脚本</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.551Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h3><h4 id="避免多次提交表单"><a href="#避免多次提交表单" class="headerlink" title="避免多次提交表单"></a>避免多次提交表单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(form, &quot;submit&quot;, function(event)&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    var target = EventUtil.getTarget(event);</div><div class="line"></div><div class="line">    //取得提交按钮</div><div class="line">    var btn = target.elements[&quot;submit-btn&quot;];</div><div class="line"></div><div class="line">    //禁用它</div><div class="line">    btn.disabled = true;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>HTML5 为表单字段新增了一个 autofocus 属性。在支持这个属性的浏览器中，只要设置这个属性，不用javascript 就能自动把焦点移动到相应字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; autofocus&gt;</div></pre></td></tr></table></figure>
<p>为了保证前面的代码在设置 autofocus 的浏览器中正常运行，必须先检查是否设置了改属性，如果设置了，就不用再调用 foucus() 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(window, &quot;load&quot;, function(event)&#123;</div><div class="line">    var element = document.forms[0].elements[0];</div><div class="line">    if (element.autofocus != true) &#123;</div><div class="line">        element.focus();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><h4 id="跨浏览器取得选择文本"><a href="#跨浏览器取得选择文本" class="headerlink" title="跨浏览器取得选择文本"></a>跨浏览器取得选择文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function getSelectedText(textbox) &#123;</div><div class="line">    if (typeof textbox.selectionStart == &quot;number&quot;) &#123;</div><div class="line">        return textbox.value.substring(textbox.selectionStart,textbox.selectionEnd);</div><div class="line">    &#125; else if (document.selection) &#123;  //IE 8-=</div><div class="line">        return document.selection.createRange().text;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="跨浏览器选择部分文本"><a href="#跨浏览器选择部分文本" class="headerlink" title="跨浏览器选择部分文本"></a>跨浏览器选择部分文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function selectText(textbox, startIndex, stopIndex) &#123;</div><div class="line">    if (textbox.setSelectionRange) &#123;</div><div class="line">        textbox.setSelectionRange(startIndex, stopIndex);</div><div class="line">    &#125; else if (textbox.createTextRange) &#123;    //IE 8-=</div><div class="line">        var range = textbox.createTextRange();</div><div class="line">        range.collapse(true);</div><div class="line">        range.moveStart(&quot;character&quot;, startIndex);</div><div class="line">        range.moveEnd(&quot;character&quot;, stopIndex - startIndex);</div><div class="line">        range.select();</div><div class="line">    &#125;</div><div class="line">    textbox.focus();</div><div class="line">&#125;</div><div class="line"></div><div class="line">textbox.value = &quot;Hello world!&quot;</div><div class="line"></div><div class="line">//选择所有文本</div><div class="line">selectText(textbox, 0, textbox.value.length);    //&quot;Hello world!&quot;</div><div class="line"></div><div class="line">//选择前3个字符</div><div class="line">selectText(text, 0, 3);    //&quot;Hel&quot;</div><div class="line"></div><div class="line">//选择第 4 到第 6 个字符</div><div class="line">selectText(textbox, 4, 7); //&quot;o w&quot;</div></pre></td></tr></table></figure>
<p>选择部分文本的技术在实现高级文本输入框时很有用，例如提供自动完成建议的文本框就可以使用这种技术。</p>
<h3 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h3><h4 id="屏蔽字符"><a href="#屏蔽字符" class="headerlink" title="屏蔽字符"></a>屏蔽字符</h4><p>下列代码只允许用户输入数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event)&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    var target = EventUtil.getTarget(event);</div><div class="line">    var charCode = EventUtil.getCharCode(event);</div><div class="line"></div><div class="line">    if(!/\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9 &amp;&amp; !event.ctrlKey) &#123;   //Safari 3-</div><div class="line">        EventUtil.preventDefault(event);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="操作剪贴板"><a href="#操作剪贴板" class="headerlink" title="操作剪贴板"></a>操作剪贴板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">getClipboardText: function(event) &#123;</div><div class="line">    var clipboardData = (event.clipboardData || window.clipboardData);</div><div class="line">    return clipboardData.getData(&quot;text&quot;);</div><div class="line">&#125;,</div><div class="line"></div><div class="line">setClipboardText: function(event)&#123;</div><div class="line">    if (event.clipboardData) &#123;</div><div class="line">        return event.clipboardData.setData(&quot;text/plain&quot;, value);</div><div class="line">    &#125; else if (window.clipboardData) &#123;</div><div class="line">        return window.clipboardData.setData(&quot;text&quot;, value);</div><div class="line">    &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>在需要确保黏贴到文本框中的文本中包含某些字符，或者符合某种格式要求时，能够访问剪贴板是非常有用的。例如，如果一个文本框只接受数值，那么久必须检测黏贴过来的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(textbox, &quot;paste&quot;, function(event)&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    var text = EventUtil.getClipboardText(event);</div><div class="line"></div><div class="line">    if(!/^\d*$/.test(text)) &#123;</div><div class="line">        EventUtil.preventDefault(event);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">    function tabForward(event) &#123;</div><div class="line">        event = EventUtil.getEvent(event);</div><div class="line">        var target = EventUtil.getTarget(event);</div><div class="line"></div><div class="line">        if (target.value.length == target.maxLength) &#123;</div><div class="line">            var form = target.form;</div><div class="line"></div><div class="line">            for(var i=0, len=form.elements.length; i &lt; len; i++) &#123;</div><div class="line">                if (form.elements[i] == target) &#123;</div><div class="line">                    if (form.elements[i+1]) &#123;</div><div class="line">                        form.elements[i+1].focus();</div><div class="line">                    &#125;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var textbox1 = document.getElementById(&quot;txtTel1&quot;);</div><div class="line">var textbox2 = document.getElementById(&quot;txtTel2&quot;);</div><div class="line">var textbox3 = document.getElementById(&quot;txtTel3&quot;);</div><div class="line"></div><div class="line">EventUtil.addHandler(textbox1, &quot;keyup&quot;, tabForward);</div><div class="line">EventUtil.addHandler(textbox2, &quot;keyup&quot;, tabForward);</div><div class="line">EventUtil.addHandler(textbox3, &quot;keyup&quot;, tabForward);</div></pre></td></tr></table></figure>
<p>不过这些代码只适用于前面给出的标记，而且没有考虑隐藏字段。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JS/">JS</a><a href="/tags/表单脚本/">表单脚本</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/继承/" title="继承" itemprop="url">继承</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.551Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承接口继承只实现方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要依靠原型链来实现的。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="别忘记默认的原型"><a href="#别忘记默认的原型" class="headerlink" title="别忘记默认的原型"></a>别忘记默认的原型</h4><p>所有的函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是搜游自定义类型都会继承toString()、valueOf()、hasOwnProperty()、isPrototypeOf()、propertyIsEnumerable()、toLocalString()、toString()方法的根本原因。</p>
<h4 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h4><p>子类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>()&#123;</div><div class="line">    this.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</div><div class="line">    this.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承了 SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">//添加新方法</div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> this.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//重写超类型中的方法</div><div class="line">SubType.prototype.getSuperValue = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    //<span class="literal">false</span></div></pre></td></tr></table></figure>
<p>当通过 SubType 的实例调用 getSuperValue() 时，调用的就是这个重新定义的方法；但通过 SuperType 的实例调用 getSuperValue()时，还会继续调用原来的那个方法。要额外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。<br>在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样就会重写原型链。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>()&#123;</div><div class="line">    this.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</div><div class="line">    this.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承了 SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">//使用字面量添加新方法，会导致上一行代码无效</div><div class="line">SubType.prototype = &#123;</div><div class="line">    geSubValue : <span class="function"><span class="title">function</span></span> ()&#123;</div><div class="line">        <span class="built_in">return</span> this.subproperty;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    someOtherMethod : <span class="function"><span class="title">function</span></span> ()&#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    //error!</div></pre></td></tr></table></figure>
<p>以上代码展示了刚刚把 SuperType 的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object 的实例，而非 SuperType 的实例，因此我们设想中的原型已经被切断了---SubType 和 SuperType 之间已经没有关系了。</p>
<h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><p>最主要的问题来自包含引用类型值的原型。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>()&#123;</div><div class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors);        //<span class="string">"red,blue,green,black"</span></div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);        //<span class="string">"red,blue,green,black"</span></div></pre></td></tr></table></figure>
<p>原型链的第二个问题是：没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上由于原型中包含引用类型值所带来的问题，实践中会单独使用原型链。</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫<strong>借用构造函数</strong>的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在(将来)新创建的对象上执行构造函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>()&#123;</div><div class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</div><div class="line">    //继承SuperType</div><div class="line">    SuperType.call(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.color);    //<span class="string">"red,blue,green,black"</span></div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.color);    //<span class="string">"red,blue,green"</span></div></pre></td></tr></table></figure>
<p>“借调”了超类型的构造函数，实际上是在(未来将要)新创建的SubType实例的环境下调用了 SuperType  构造函数。这样一来，就会在新 SubType 对象上执行 SuperType() 函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会有自己的 colors 属性的副本了</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> SuperType(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</div><div class="line">    //继承了SuperType,同时还传递了参数</div><div class="line">    SuperType.call(this,<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line">    //实例属性</div><div class="line">    this.age = 29;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.name);        //<span class="string">"Nicholas"</span>;</div><div class="line">alert(instance.age);         //29</div></pre></td></tr></table></figure>
<p>为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p>
<h4 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h4><p>方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承，有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> SuperType(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> SubType(name,age)&#123;</div><div class="line">    //继承属性</div><div class="line">    SuperType.call(this,name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承方法</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">SubType.Prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType(<span class="string">"Nicholas"</span>, 29);</div><div class="line">instance1.color.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.color);        //<span class="string">"red,blue,green,black"</span></div><div class="line">instance1.sayName();           //<span class="string">"Nicholas"</span></div><div class="line">instance1.sayAge();            //29</div><div class="line"></div><div class="line">var instance2 = new SubType(<span class="string">"Greg"</span>, 27);</div><div class="line">alert(instance2.color);        //<span class="string">"red,blue,green"</span></div><div class="line">instance2.sayName();           //<span class="string">"Greg"</span></div><div class="line">instance2.sayAge();            //27</div></pre></td></tr></table></figure>
<p>组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof 和 isPrototypeOf() 也能够用于识别组合继承创建的对象。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>ECMAScript5 通过新增 Object.create() 方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson = Object.create(person);</div><div class="line">anotherPerson.name = <span class="string">"Greg"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"></div><div class="line">var yetAnotherPerson = Object.create(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line"></div><div class="line">alert(person.friends);        //<span class="string">"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure>
<p>Object.create() 方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson = Object.create(person, &#123;</div><div class="line">    name: &#123;</div><div class="line">        value: <span class="string">"Greg"</span></div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name);    //<span class="string">"Greg"</span></div></pre></td></tr></table></figure>
<p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类型的情况下，原型式继承是完全可以胜任的。不过，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型式继承紧密相关的一种思路，它与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> createAnother(original) &#123;</div><div class="line">    var <span class="built_in">clone</span> = object(original);    //通过调用函数创建一个新对象</div><div class="line">    clone.sayHi = <span class="function"><span class="title">function</span></span>()&#123;        //以某种方式来增强这个对象</div><div class="line">        alert(<span class="string">"hi"</span>)</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">clone</span>;                    //返回这个对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anothorPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi();    //<span class="string">"hi"</span></div></pre></td></tr></table></figure>
<p>新对象不仅具有 person 的所有属性和方法，而且还有自己sayHi()方法<br>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object() 函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<blockquote>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
</blockquote>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> SuperType(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> SubType(name,age)&#123;</div><div class="line">    SuperTpye.call(this, name);                    //第二次调用 SuperType()</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = new SuperType();               //第一次调用 SuperType()</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第一次调用 SuperType 构造函数时，SubType.prototype 会得到两个属性：name 和 colors; 它们都是 SuperType 的实例属性，只不过现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这一次又在新对象上创建了实例属性 name 和 colors。于是，这两个属性就屏蔽了原型中的两个同名属性。<br>好在已经找到了解决这个问题的方法---寄生组合式继承。<br>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> inheritPrototype(subType, superType)&#123;</div><div class="line">    var prototype = Object(superType.prototype);        //创建对象</div><div class="line">    prototype.constructor = subType;                    //增强对象</div><div class="line">    subTye.prototype = prototype;                       //指定对象</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> SuperType(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> SubType(name, age)&#123;</div><div class="line">    SuperType.call(this.name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个例子的高效率体现在它值调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的，多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf()。 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/继承/">继承</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/词法作用域/" title="词法作用域" itemprop="url">词法作用域</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.551Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另外一种叫作动态作用域，仍有一些编程语言在使用（比如<br>Bash脚本、Perl中的一些模式等）。</p>
<h3 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h3><p>大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。词<br>法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。<br>这个概念是理解词法作用域及其名称来历的基础。<br>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将<br>变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情<br>况下是这样的）。</p>
<p>考虑以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">    var b = a * 2;</div><div class="line">function bar(c) &#123;</div><div class="line">    console.log( a, b, c );</div><div class="line">&#125;</div><div class="line">bar( b * 3 );</div><div class="line">&#125;</div><div class="line">foo( 2 ); // 2, 4, 12</div></pre></td></tr></table></figure>
<p>在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含的气泡。</p>
<p><img src="img/blog/Lexing_1.png"></p>
<p>气泡1包含着整个全局作用域，其中只有一个标识符：foo。<br>气泡2包含着foo所创建的作用域，其中有三个标识符：a、bar和b。<br>气泡3包含着bar所创建的作用域，其中只有一个标识符：c。<br>作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的。</p>
<p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识<br>符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从<br>运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p>
<blockquote>
<p>全局变量会自动成为全局对象（比如浏览器中的window对象）的属性，因此可以不直接通<br>过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.a</div></pre></td></tr></table></figure>
<blockquote>
<p>通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无<br>论如何都无法被访问到。</p>
</blockquote>
<p><b>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置<br>决定。</b><br>词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查<br>找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访<br>问。</p>
<h3 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h3><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以<br>说欺骗）词法作用域呢？<br>JavaScript中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是什么好<br>方法。但是关于它们的争论通常会忽略掉最重要的点：欺骗词法作用域会导致性能下降。</p>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>JavaScript中的eval(..)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存<br>在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码<br>是写在那个位置的一样。</p>
<p>考虑以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(str, a) &#123;</div><div class="line">    eval( str ); // 欺骗！</div><div class="line">    console.log( a, b );</div><div class="line">&#125;</div><div class="line">var b = 2;</div><div class="line">foo( &quot;var b = 3;&quot;, 1 ); // 1, 3</div></pre></td></tr></table></figure>
<p>eval(..)调用中的”var b = 3;”这段代码会被当作本来就在那里一样来处理。由于那段代码声明了<br>一个新的变量b，因此它对已经存在的foo(..)的词法作用域进行了修改。事实上，和前面提到的原<br>理一样，这段代码实际上在foo(..)内部创建了一个变量b，并遮蔽了外部（全局）作用域中的同名<br>变量。</p>
<blockquote>
<p>在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法<br>修改所在的作用域。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(str) &#123;</div><div class="line">    &quot;use strict&quot;;</div><div class="line">    eval( str );</div><div class="line">    console.log( a ); // ReferenceError: a is not defined</div><div class="line">&#125;</div><div class="line">foo( &quot;var a = 2&quot;);</div></pre></td></tr></table></figure>
<p>JavaScript中还有其他一些功能效果和eval(..)很相似。setTimeout(..)和setInterval(..)的第一<br>个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时<br>且并不被提倡。不要使用它们！<br>new Function(..)函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生<br>成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval(..)略微安全一<br>些，但也要尽量避免使用。<br>在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。</p>
<h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>JavaScript中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with关键<br>字。可以有很多方法来解释with，在这里我选择从这个角度来解释它：它如何同被它所影响的词法<br>作用域进行交互。<br>with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    a: 1,</div><div class="line">    b: 2,</div><div class="line">    c: 3</div><div class="line">&#125;;</div><div class="line">// 单调乏味的重复&quot;obj&quot;</div><div class="line">obj.a = 2;</div><div class="line">obj.b = 3;</div><div class="line">obj.c = 4;</div><div class="line">// 简单的快捷方式</div><div class="line">with (obj) &#123;</div><div class="line">    a = 3;</div><div class="line">    b = 4;</div><div class="line">    c = 5;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但实际上这不仅仅是为了方便地访问对象属性。考虑如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function foo(obj) &#123;</div><div class="line">    with (obj) &#123;</div><div class="line">        a = 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var o1 = &#123;</div><div class="line">    a: 3</div><div class="line">&#125;;</div><div class="line">var o2 = &#123;</div><div class="line">    b: 3</div><div class="line">&#125;;</div><div class="line">foo( o1 );</div><div class="line">console.log( o1.a ); // 2</div><div class="line">foo( o2 );</div><div class="line">console.log( o2.a ); // undefined</div><div class="line">console.log( a ); // 2——不好，a被泄漏到全局作用域上了！</div></pre></td></tr></table></figure></p>
<p>这个例子中创建了o1和o2两个对象。其中一个具有a属性，另外一个没有。foo(..)函数接受一个obj<br>参数，该参数是一个对象引用，并对这个对象引用执行了with(obj) {..}。在with块内部，我们写的<br>代码看起来只是对变量a进行简单的词法引用，实际上就是一个LHS引用（查看第1章），并将2赋值<br>给它。<br>当我们将o1传递进去，a = 2赋值操作找到了o1.a并将2赋值给它，这在后面的console.log(o1.a)中<br>可以体现。而当o2传递进去，o2并没有a属性，因此不会创建这个属性，o2.a保持undefined。<br>但是可以注意到一个奇怪的副作用，实际上a = 2赋值操作创建了一个全局的变量a。这是怎么回<br>事？<br>with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属<br>性也会被处理为定义在这个作用域中的词法标识符。</p>
<blockquote>
<p>尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被<br>限制在这个块的作用域中，而是被添加到with所处的函数作用域中。</p>
</blockquote>
<p>eval(..)函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明<br>实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。<br>可以这样理解，当我们传递o1给with时，with所声明的作用域是o1，而这个作用域中含有一个<br>同o1.a属性相符的标识符。但当我们将o2作为作用域时，其中并没有a标识符，因此进行了正常的<br>LHS标识符查找。<br>o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a = 2执行时，自动创建<br>了一个全局变量（因为是非严格模式）。</p>
<blockquote>
<p>另外一个不推荐使用eval(..)和with的原因是会被严格模式所影响（限制）。with被完全<br>禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..)也被禁止了。</p>
</blockquote>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>如果代码中大量使用eval(..)或with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将<br>这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这<br>个事实。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/Type-Grammar/">Type & Grammar</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/函数表达式/" title="函数表达式" itemprop="url">函数表达式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.535Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">    if(num &lt;= 1)&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;else&#123;</div><div class="line">        return num * arguments.callee(num-1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过使用 argument.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归函数时，使用 arguments.callee 总比使用函数名更保险。<br>但在严格模式下，不能通过脚本访问 arguments.callee, 访问这个属性会导致错误。不过，可以使用函数表达式来达成相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var factorial = (function f(num)) &#123;</div><div class="line">    if (num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else&#123;</div><div class="line">        return num * f(num-1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction(propertyName) &#123;</div><div class="line">    return function(object1, object2) &#123;</div><div class="line">        var value1 = object1[propertyName];</div><div class="line">        var value2 = object2[propertyName];</div><div class="line"></div><div class="line">        if (value1 &lt; value2) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125; else if (value1 &gt; value2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部函数的代码访问了外部函数中的变量 propertyName。 即使这个内部函数被返回了，而且是在其它地方被调用了，但它仍然可以访问变量propertyName。之所以还能访问这个变量，是因为内部函数的作用域中包含 createComparisonFunction() 的作用域。要彻底搞清楚其中的细节，必须从理解函数被调用的时候都会发生什么入手。<br>当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终位于第二位，外部函数的外部函数的活动对象始终位于第三位，……直至作为作用域终点的全局执行环境。<br>在函数执行过程中，为读取和写入变量的值，就需要在作用域中查找变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2) &#123;</div><div class="line">    if (value1 &lt; value2) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125; else if (value1 &gt; value2) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result = compare(5, 10);</div></pre></td></tr></table></figure>
<p>以上代码先定义了 compare() 函数， 然后又在全局作用域中调用了它。当调用 compare() 时，会创建一个包含 arguments、value1、value2 的活动对象。全局执行环境(包含 result 和 compare) 在 compare() 执行环境的作用域链中则处于第二位。</p>
<p>后台的每个执行环境都有一个表示变量的对象---变量对象。全局环境的变量对象始终存在，而像 compare() 函数这样的局部环境的变量对象，则只在函数的执行的过程中存在。<br>无论什么时候再函数中访问一个变量时，就会从作用域链中搜索具有响应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。但是，闭包的情况又有所不同。<br>在另一个<br>在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。因此，在 createComparisonFunction() 函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数 createComparisonFunction() 的活动对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var compare = createComparisonFunction(<span class="string">"name"</span>);</div><div class="line">var result = compare(&#123;name: <span class="string">"Nicholas"</span>&#125;, &#123;name: <span class="string">"Greg"</span>&#125;);</div></pre></td></tr></table></figure>
<p>在匿名函数从 createComparisonFunction() 中被返回后，它的作用域链被初始化为包含 createComparisonFunction() 函数的活动对象和全局变量对象。这样，匿名函数就可以访问在 createComparisonFunction() 中定义的所有变量。更为重要的是，createComparisonFunction() 函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当 createComparisonFunction() 函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁返回后，createComparisonFunction() 的活动对象才会被销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//创建函数</div><div class="line">var compareNames = createComparisonFunction(&quot;name&quot;);</div><div class="line"></div><div class="line">//调用函数</div><div class="line">var result = compareNames(&#123; name: &quot;Nicholas&quot;&#125;, &#123; name, &quot;Greg&quot;&#125;);</div><div class="line"></div><div class="line">//解除对匿名函数的引用(以便释放内存)</div><div class="line">compareNames = null;</div></pre></td></tr></table></figure>
<p>首先，创建的比较函数被保存在变量 compareNames 中。而通过将 compareNames 设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其它作用域(除了全局作用域)也都可以安全地销毁了。</p>
<h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function createFunctions()&#123;</div><div class="line">    var result = new Array();</div><div class="line">    for (var i=0; i &lt; 10; i++) &#123;</div><div class="line">        result[i] = function()&#123;</div><div class="line">            return i;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时每个函数都引用着保存变量 i 的同一个变量对象，所以在每个函数内部 i 的值都是10.但是，可以通过创建另一个匿名函数强制让闭包的行为符合预期。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">createFunctions</span></span>()&#123;</div><div class="line">    var result = new Array();</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(var i=0; i &lt; 10; i++) &#123;</div><div class="line">        result[i] = <span class="keyword">function</span>(num)&#123;</div><div class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">                <span class="built_in">return</span> num;</div><div class="line">            &#125;;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><p>this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向window。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name : <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    getNameFunc : <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">            <span class="built_in">return</span> this.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(object.getNameFunc()());        //<span class="string">"The Window"</span> (在非严格模式下)</div></pre></td></tr></table></figure>
<p>每个函数在被调用时都会自动取得这两个特殊变量：this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</p>
<blockquote>
<p>this 和 arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象，必须将该对象的引用保存到另一个闭包能够访问的变量中。</p>
</blockquote>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>如果闭包的作用域链中保存着一个HTML元素，那么久意味着该元素无法被销毁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">assignHandler</span></span>()&#123;</div><div class="line">    var element = document.getElementById(<span class="string">"someElement"</span>);</div><div class="line">    element.onclick = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        alert(element.id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个闭包创建了一个循环引用。由于匿名函数保存了一个对 assignHandler() 的活动对象的引用，因此就会导致无法减少 element 的引用数。只要匿名函数存在，element 的引用数至少也是 1，因此它所占用的内存就永远不会被回收。不过，这个问题可以通过稍微改一下代码来解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">assignHandler</span></span>()&#123;</div><div class="line">    var element = document.getElementById(<span class="string">"someElement"</span>);</div><div class="line">    var id = element.id;</div><div class="line"></div><div class="line">    element.onclick = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        alert(id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    element = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消除循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。因为闭包会引用闭包包含函数的整个活动对象，而其中包含着 element。即使闭包不直接引用 element，包含函数的活动对象中也仍然会保存引用。因此，有必要把 element 变量设为 null。这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。</p>
<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function outputNumbers(count) &#123;</div><div class="line">    (function () &#123;</div><div class="line">        for (var i=0; i &lt; count; i++) &#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;</div><div class="line">        &#125;)();</div><div class="line">        alert(i);    //导致一个错误！</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>有权访问私有变量和私有函数的公有方法称为<em>特权方法</em>。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyObject</span></span>() &#123;</div><div class="line">    //私有变量和私有函数</div><div class="line">    var privateVariable = 10;</div><div class="line"></div><div class="line">    <span class="keyword">function</span> <span class="function"><span class="title">privateFunction</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //特权方法</div><div class="line">    this.publicMethod = <span class="function"><span class="title">function</span></span> ()&#123;</div><div class="line">        privateVariable++;</div><div class="line">        <span class="built_in">return</span> privateFunction();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用私有和特权成员，可以隐藏那些不应该直接被修改的数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Person(name) &#123;</div><div class="line"></div><div class="line">    this.getName = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.setName = <span class="keyword">function</span>(value)&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = new Person(<span class="string">"Nicholas"</span>);</div><div class="line">alert(person.getName());        //<span class="string">"Nicholas"</span></div><div class="line">person.setName(<span class="string">"Greg"</span>);</div><div class="line">alert(person.getName());        //<span class="string">"Greg"</span></div></pre></td></tr></table></figure>
<p>在函数中定义特权方法也有缺点，那就是必须使用构造函数模式来达到这个目的。构造函数的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。</p>
<h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><p>通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line"></div><div class="line">    //私有变量和私有函数</div><div class="line">    var privateVariable = 10;</div><div class="line"></div><div class="line">    <span class="keyword">function</span> <span class="function"><span class="title">privateFunction</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //构造函数</div><div class="line">    MyObject = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    //公有/特权方法</div><div class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        privateVariable++;</div><div class="line">        <span class="built_in">return</span> privateFunction();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#125;)();</div></pre></td></tr></table></figure>
<p>这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明Object时使用 var 关键字。初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject 就成了一个全局变量，能够在私有作用域外被访问到。但在严格模式下给未经生命的变量赋值会导致错误。<br>这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    var name = <span class="string">""</span>;</div><div class="line"></div><div class="line">    Person = <span class="keyword">function</span>(value)&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Person.prototype.setName = <span class="keyword">function</span>(value)&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">    &#125;)();</div><div class="line"></div><div class="line">    var person1 = new Person(<span class="string">"Nicholas"</span>);</div><div class="line">    alert(person1.getName());    //<span class="string">"Nicholas"</span></div><div class="line">    person1.setName(<span class="string">"Greg"</span>);</div><div class="line">    alert(person1.getName());    //<span class="string">"Greg"</span></div><div class="line"></div><div class="line">    var person2 = new Person(<span class="string">"Michael"</span>);</div><div class="line">    alert(person1.getName());    //<span class="string">"Michael"</span></div><div class="line">    alert(person2.getName());    //<span class="string">"Michael"</span></div></pre></td></tr></table></figure>
<p>在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用 setName() 会影响所有实例。而调用 seName() 或新建一个 Person 实例都会赋予 name 属性一个新值。<br>以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视具体需求而定。</p>
<blockquote>
<p>多查找作用域链中的一个层次，就会在一定程度上影响查找速度。而这正是使用闭包和私有变量的一个明显的不足之处。</p>
</blockquote>
<h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>前面的模式是用于为自定义类型创建私有变量和特权方法的。而模块模式则是为单例创建私有变量和特权方法。所谓单例，值得就是只有一个实例的对象。按照惯例，Javascript是以对象字面量的方式来创建单例对象的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var singleton = &#123;</div><div class="line">    name : value,</div><div class="line">    method : <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        //这里是方法的代码</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var singleton = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line"></div><div class="line">    //私有变量和私有函数</div><div class="line">    var privateVariable = 10;</div><div class="line"></div><div class="line">    <span class="keyword">function</span> <span class="function"><span class="title">privateFunction</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //特权/公有方法和属性</div><div class="line">    <span class="built_in">return</span> &#123;</div><div class="line">        publicProperty: <span class="literal">true</span>,</div><div class="line"></div><div class="line">        publicMethod : <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">            privateVariable++;</div><div class="line">            <span class="built_in">return</span> privateFunction();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var application = function()&#123;</div><div class="line"></div><div class="line">    //私有变量和函数</div><div class="line">    var components = new Array();</div><div class="line"></div><div class="line">    //初始化</div><div class="line">    components.push(new BaseComponent());</div><div class="line"></div><div class="line">    //公共</div><div class="line">    return &#123;</div><div class="line">        getComponentCount : function()&#123;</div><div class="line">            return components.length;</div><div class="line">            &#125;,</div><div class="line"></div><div class="line">        registerComponent : function(component)&#123;</div><div class="line">            if (typeof component == &quot;object&quot;) &#123;</div><div class="line">                components.push(component);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>如果必须创建一个对象并以某些数据对其初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 Object 的实例，因为最终要通过一个对象字面量来表示它。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/函数表达式/">函数表达式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/this全面解析/" title="this全面解析" itemprop="url">this全面解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.535Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规<br>则时的默认规则。<br>思考一下下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // 2</div></pre></td></tr></table></figure></p>
<p>你应该注意到的第一件事是，声明在全局作用域中的变量（比如var a = 2）就是全局对象的一个同<br>名属性。它们本质上就是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。<br>接下来我们可以看到当调用foo()时，this.a被解析成了全局变量a。为什么？因为在本例中，函数<br>调用时应用了this的默认绑定，因此this指向全局对象。<br>那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看foo()是如何调用的。在<br>代码中，foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应<br>用其他规则。<br>如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此this会绑定<br>到undefined：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    &quot;use strict&quot;;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // TypeError: this is undefined</div></pre></td></tr></table></figure></p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不<br>过这种说法可能会造成一些误导。<br>思考下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a: 2,</div><div class="line">    foo: foo</div><div class="line">&#125;;</div><div class="line">obj.foo(); // 2</div></pre></td></tr></table></figure></p>
<p>当函数引用有上下文<br>对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。因为调用foo()时this被绑<br>定到obj，因此this.a和obj.a是一样的。</p>
<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj2 = &#123;</div><div class="line">    a: 42,</div><div class="line">    foo: foo</div><div class="line">&#125;;</div><div class="line">var obj1 = &#123;</div><div class="line">    a: 2,</div><div class="line">    obj2: obj2</div><div class="line">&#125;;</div><div class="line">obj1.obj2.foo(); // 42</div></pre></td></tr></table></figure></p>
<h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><p>一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑<br>定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。<br>思考下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a: 2,</div><div class="line">    foo: foo</div><div class="line">&#125;;</div><div class="line">var bar = obj.foo; // 函数别名！</div><div class="line">var a = &quot;oops, global&quot;; // a是全局对象的属性</div><div class="line">bar(); // &quot;oops, global&quot;</div></pre></td></tr></table></figure></p>
<p>虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一<br>个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">function doFoo(fn) &#123;</div><div class="line">    // fn其实引用的是foo</div><div class="line">    fn(); // &lt;-- 调用位置！</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a: 2,</div><div class="line">    foo: foo</div><div class="line">&#125;;</div><div class="line">var a = &quot;oops, global&quot;; // a是全局对象的属性</div><div class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</div><div class="line">参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子</div><div class="line">一样。</div></pre></td></tr></table></figure></p>
<p>如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没<br>有区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a: 2,</div><div class="line">    foo: foo</div><div class="line">&#125;;</div><div class="line">var a = &quot;oops, global&quot;; // a是全局对象的属性</div><div class="line">setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</div></pre></td></tr></table></figure></p>
<p>JavaScript环境中内置的setTimeout()函数实现和下面的伪代码类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function setTimeout(fn,delay) &#123;</div><div class="line">    // 等待delay毫秒</div><div class="line">    fn(); // &lt;-- 调用位置！</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就像我们看到的那样，回调函数丢失this绑定是非常常见的。除此之外，还有一种情况this的行为<br>会出乎我们意料：调用回调函数的函数可能会修改this。在一些流行的JavaScript库中事件处理器<br>常会把回调函数的this强制绑定到触发事件的DOM元素上。这在一些情况下可能很有用，但是有<br>时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。<br>无论是哪种情况，this的改变都是意想不到的，实际上你无法控制回调函数的执行方式，因此就没<br>有办法控制会影响绑定的调用位置。</p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>JavaScript中的“所有”函数都有一些有用的特性，可以用来解决这个问题。具体点说，可以使用函数的call(..)和apply(..)方法。JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使用call(..)<br>和apply(..)方法。</p>
<p>这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着<br>在调用函数时指定这个this。因为你可以直接指定this的绑定对象，因此我们称之为显式绑定。<br>思考下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a:2</div><div class="line">&#125;;</div><div class="line">foo.call( obj ); // 2</div></pre></td></tr></table></figure></p>
<p>通过foo.call(..)，我们可以在调用foo时强制把它的this绑定到obj上。</p>
<p>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作this的绑定对象，这个原<br>始值会被转换成它的对象形式（也就是new String(..)、new Boolean(..)或者new Number(..)）。这通<br>常被称为“装箱”。</p>
<p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p>
<h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><p>但是显式绑定的一个变种可以解决这个问题。<br>思考下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a:2</div><div class="line">&#125;;</div><div class="line">var bar = function() &#123;</div><div class="line">    foo.call( obj );</div><div class="line">&#125;;</div><div class="line">bar(); // 2</div><div class="line">setTimeout( bar, 100 ); // 2</div><div class="line">// 硬绑定的bar不可能再修改它的this</div><div class="line">bar.call( window ); // 2</div></pre></td></tr></table></figure></p>
<p>硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo(something) &#123;</div><div class="line">    console.log( this.a, something );</div><div class="line">    return this.a + something;</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a:2</div><div class="line">&#125;;</div><div class="line">var bar = function() &#123;</div><div class="line">    return foo.apply( obj, arguments );</div><div class="line">&#125;;</div><div class="line">var b = bar( 3 ); // 2 3</div><div class="line">console.log( b ); // 5</div></pre></td></tr></table></figure></p>
<p>另一种使用方法是创建一个bind可以重复使用的辅助函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function foo(something) &#123;</div><div class="line">    console.log( this.a, something );</div><div class="line">    return this.a + something;</div><div class="line">&#125;</div><div class="line">// 简单的辅助绑定函数</div><div class="line">function bind(fn, obj) &#123;</div><div class="line">    return function() &#123;</div><div class="line">        return fn.apply( obj, arguments );</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a:2</div><div class="line">&#125;;</div><div class="line">var bar = bind( foo, obj );</div><div class="line">var b = bar( 3 ); // 2 3</div><div class="line">console.log( b ); // 5</div></pre></td></tr></table></figure></p>
<p>由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind，它<br>的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(something) &#123;</div><div class="line">    console.log( this.a, something );</div><div class="line">return this.a + something;</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a:2</div><div class="line">&#125;;</div><div class="line">var bar = foo.bind( obj );</div><div class="line">var b = bar( 3 ); // 2 3</div><div class="line">console.log( b ); // 5</div></pre></td></tr></table></figure></p>
<p>bind(..)会返回一个硬编码的新函数，它会把参数设置为this的上下文并调用原始函数。</p>
<h4 id="API调用的”上下文”"><a href="#API调用的”上下文”" class="headerlink" title="API调用的”上下文”"></a>API调用的”上下文”</h4><p>第三方库的许多函数，以及JavaScript语言和宿主环境中许多新的内置函数，都提供了一个可选的<br>参数，通常被称为“上下文”（context），其作用和bind(..)一样，确保你的回调函数使用指定的this。<br>举例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo(el) &#123;</div><div class="line">console.log( el, this.id );</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">id: &quot;awesome&quot;</div><div class="line">&#125;;</div><div class="line">// 调用foo(..)时把this绑定到obj</div><div class="line">[1, 2, 3].forEach( foo, obj );</div><div class="line">// 1 awesome 2 awesome 3 awesome</div></pre></td></tr></table></figure></p>
<p>这些函数实际上就是通过call(..)或者apply(..)实现了显式绑定，这样你可以少些一些代码。</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用new初始化类时会调用类中的<br>构造函数。通常的形式是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">something = new MyClass(..);</div></pre></td></tr></table></figure></p>
<p>JavaScript也有一个new操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都<br>认为JavaScript中new的机制也和那些语言一样。然而，JavaScript中new的机制实际上和面向类的<br>语言完全不同。</p>
<p>首先我们重新定义一下JavaScript中的“构造函数”。JavaScript，构造函数只是一些使用new操作符<br>时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一<br>种特殊的函数类型，它们只是被new操作符调用的普通函数而已。<br>举例来说，思考一下Number(..)作为构造函数时的行为，ES5.1中这样描述它：</p>
<blockquote>
<p>15.7.2 Number构造函数<br>当Number在new表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。</p>
</blockquote>
<p>所以，包括内置对象函数（比如Number(..)，详情请查看第3章）在内的所有函数都可以用new来调<br>用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所<br>谓的“构造函数”，只有对于函数的“构造调用”。<br>使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行[[原型]]连接。</li>
<li>这个新对象会绑定到函数调用的this。</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。<br>思考下面的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">    this.a = a;</div><div class="line">&#125;</div><div class="line">var bar = new foo(2);</div><div class="line">console.log( bar.a ); // 2</div></pre></td></tr></table></figure>
</li>
</ol>
<p>使用new来调用foo(..)时，我们会构造一个新对象并把它绑定到foo(..)调用中的this上。new是最<br>后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ol>
<li><p>函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bar = new foo()</div></pre></td></tr></table></figure>
</li>
<li><p>函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bar = foo.call(obj2)</div></pre></td></tr></table></figure>
</li>
<li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bar = obj1.foo()</div></pre></td></tr></table></figure>
</li>
<li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bar = foo()</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h3><p>####被忽略的this<br>如果你把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被<br>忽略，实际应用的是默认绑定规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo.call( null ); // 2</div></pre></td></tr></table></figure></p>
<p>那么什么情况下你会传入null呢？<br>一种非常常见的做法是使用apply(..)来“展开”一个数组，并当作参数传入一个函数。类似<br>地，bind(..)可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">    console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>// 把数组“展开”成参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo.apply( null, [2, 3] ); // a:2, b:3</div><div class="line">// 使用 bind(..) 进行柯里化</div><div class="line">var bar = foo.bind( null, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>
<p>这两种方法都需要传入一个参数当作this的绑定对象。如果函数并不关心this的话，你仍然需要<br>传入一个占位值，这时null可能是一个不错的选择，就像代码所示的那样。</p>
<p>然而，总是使用null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this（比如第<br>三方库中的一个函数），那默认绑定规则会把this绑定到全局对象（在浏览器中这个对象<br>是window），这将导致不可预计的后果（比如修改全局对象）。<br>显而易见，这种方式可能会导致许多难以分析和追踪的bug。</p>
<h5 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h5><p>一种“更安全”的做法是传入一个特殊的对象，把this绑定到这个对象不会对你的程序产生任何副<br>作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demilitarized zone，非军事区）对象<br>——它就是一个空的非委托的对象（委托在第5章和第6章介绍）。<br>如果我们在忽略this绑定时总是传入一个DMZ对象，那就什么都不用担心了，因为任何对于this<br>的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。</p>
<p>JavaScript中创建一个空对象最简单的方法都是Object.create(null)Object.create(null)和{}很像，但是并不会创建Object.prototype这个委托，所以它<br>比{}”更空”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">    console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125;</div><div class="line">// 我们的DMZ空对象</div><div class="line">var ø = Object.create( null );</div><div class="line">// 把数组展开成参数</div><div class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</div><div class="line">// 使用bind(..)进行柯里化</div><div class="line">var bar = foo.bind( ø, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>
<p>使用变量名ø不仅让函数变得更加“安全”，而且可以提高代码的可读性，因为ø表示“我希望this是<br>空”，这比null的含义更清楚。</p>
<h4 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h4><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调<br>用这个函数会应用默认绑定规则。<br>间接引用最容易在赋值时发生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">`console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">var o = &#123; a: 3, foo: foo &#125;;</div><div class="line">var p = &#123; a: 4 &#125;;</div><div class="line">o.foo(); // 3</div><div class="line">(p.foo = o.foo)(); // 2</div></pre></td></tr></table></figure></p>
<p>赋值表达式p.foo = o.foo的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或<br>者o.foo()。根据我们之前说过的，这里会应用默认绑定。<br>注意：对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是<br>否处于严格模式。如果函数体处于严格模式，this会被绑定到undefined，否则this会被绑定到全局<br>对象。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/Type-Grammar/">Type & Grammar</a><a href="/tags/this/">this</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/事件/" title="事件" itemprop="url">事件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.535Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line">        //跨浏览器的事件处理程序</div><div class="line">        addHandler: function(element, type, handler) &#123;</div><div class="line">            if (element.addEventListener) &#123;</div><div class="line">                element.addEventListener(type, handler, false);</div><div class="line">            &#125; else if (element.attachEvent) &#123;</div><div class="line">                element.attachEvent(&quot;on&quot; + type, handler);</div><div class="line">            &#125; else &#123;</div><div class="line">                element[&quot;on&quot; + type] = handler;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        removeHandler: function(element, type, handler) &#123;</div><div class="line">            if (element.removeEventListener) &#123;</div><div class="line">                element.removeEventListener(type, handler, false);</div><div class="line">            &#125; else if (element.detachEvent) &#123;</div><div class="line">                element.detachEvent(&quot;on&quot; + type, handler);</div><div class="line">            &#125; else &#123;</div><div class="line">                element[&quot;on&quot; + type] = null;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        //跨浏览器的事件对象</div><div class="line">        getEvent: function(event) &#123;</div><div class="line">            return event ? event : window.event;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        getTarget: function(event) &#123;</div><div class="line">            return event.target || event.srcElement;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        preventDefault: function(event) &#123;</div><div class="line">            if (event.preventDefault) &#123;</div><div class="line">                event.preventDefault();</div><div class="line">            &#125; else &#123;</div><div class="line">                event.returnValue = false;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        stopPropagation: function(event) &#123;</div><div class="line">            if (event.stopPropagation) &#123;</div><div class="line">                event.stopPropagation();</div><div class="line">            &#125; else &#123;</div><div class="line">                event.cancelBubble = true;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        //跨浏览器取得相关元素</div><div class="line">        getRelatedTarget: function(event) &#123;</div><div class="line">            if (event.relatedTarget) &#123;</div><div class="line">                return event.relatedTarget;</div><div class="line">            &#125; else if (event.toElement) &#123;</div><div class="line">                return event.toElement;</div><div class="line">            &#125; else if (event.fromElement) &#123;</div><div class="line">                return event.fromElement;</div><div class="line">            &#125; else &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        //鼠标按钮</div><div class="line">        getButton: function(event) &#123;</div><div class="line">            if (document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;)) &#123;</div><div class="line">                return event.button;</div><div class="line">            &#125; else &#123;</div><div class="line">                switch(event.button) &#123;</div><div class="line">                    case 0:</div><div class="line">                    case 1:</div><div class="line">                    case 3:</div><div class="line">                    case 5:</div><div class="line">                    case 7:</div><div class="line">                        return 0;</div><div class="line">                    case 2:</div><div class="line">                    case 6:</div><div class="line">                        return 2;</div><div class="line">                    case 4:</div><div class="line">                        return 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        //鼠标滚轮事件</div><div class="line">        getWheelDelta: function(event) &#123;</div><div class="line">            if (event.wheelDelta) &#123;</div><div class="line">                return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta);</div><div class="line">            &#125; else &#123;</div><div class="line">                return -event.detail * 40;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        //字符编码</div><div class="line">        getCharCode: function(event) &#123;</div><div class="line">            if (typeof event.charCode == &quot;number&quot;) &#123;</div><div class="line">                return event.charCode;    //只有在发生keypress事件才包含值</div><div class="line">            &#125; else &#123;</div><div class="line">                return event.keyCode;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        //操作剪贴板</div><div class="line">        getClipboardText: function(event) &#123;</div><div class="line">            var clipboardData = (event.clipboardData || window.clipboardData);</div><div class="line">            return clipboardData.getData(&quot;text&quot;);</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        setClipboardText: function(event)&#123;</div><div class="line">            if (event.clipboardData) &#123;</div><div class="line">                return event.clipboardData.setData(&quot;text/plain&quot;, value);</div><div class="line">            &#125; else if (window.clipboardData) &#123;</div><div class="line">                return window.clipboardData.setData(&quot;text&quot;, value);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"> //跨浏览器的事件处理程序示例：</div><div class="line">var btn = document.getElementById(&quot;myBtn&quot;);</div><div class="line">var handler = function()&#123;</div><div class="line">    alert(&quot;Clicked&quot;);</div><div class="line">&#125;;</div><div class="line">EventUtil.addHandler(btn, &quot;click&quot;, handler);</div><div class="line"></div><div class="line">//这里省略其它代码</div><div class="line"></div><div class="line">EventUtil.removeHandler(btn, &quot;click&quot;, handler);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//跨浏览器取得相关元素示例：</div><div class="line">var div = document.getElementById(&quot;myDiv&quot;);</div><div class="line">EventUtil.addHandler(div, &quot;mouseout&quot;, function(event)&#123;</div><div class="line">    event = Event.getEvent(event);</div><div class="line">    var target = EventUtil.getTarget(event);</div><div class="line">    var relatedTarget = EventUtil.getRelatedTarget(event);</div><div class="line">    alert(&quot;Moused out fo &quot; + target.tagName + &quot; to &quot; + relatedTarget.tagName);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><h4 id="客户区坐标位置"><a href="#客户区坐标位置" class="headerlink" title="客户区坐标位置"></a>客户区坐标位置</h4><p>可以使用类似下列代码取得鼠标事件的客户端坐标信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var div = document.getElementById(&quot;myDiv&quot;);</div><div class="line">EventUtil.addHandler(div, &quot;click&quot;, function(event)&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(&quot;Client coordinates: &quot; + event.clientX + &quot;,&quot; + event.clientY);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h4 id="修改键"><a href="#修改键" class="headerlink" title="修改键"></a>修改键</h4><p>当某个鼠标事件发生时，通过检测这几个属性就可以确定用户是否同时按下了其中的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var div = document.getElementById(&quot;myDiv&quot;);</div><div class="line">EventUtil.addHandler(div, &quot;click&quot;, function(event)&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    var keys = new Array();</div><div class="line"></div><div class="line">    if (event.shiftKey) &#123;</div><div class="line">        keys.push(&quot;shift&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (event.ctrlKey) &#123;</div><div class="line">        keys.push(&quot;ctrlKey&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (event.altKey) &#123;</div><div class="line">        keys.push(&quot;altKey&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (event.metaKey) &#123;</div><div class="line">        keys.push(&quot;metaKey&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    alert(&quot;Keys: &quot; + keys.join(&quot;,&quot;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><h4 id="textInput-事件"><a href="#textInput-事件" class="headerlink" title="textInput 事件"></a>textInput 事件</h4><p>这个用于替代 keypress 的textInput 事件的行为稍有不同。区别之一就是任何可以获得焦点的元素都可以触发 keypress 事件，但只有可编辑区域才能触发 textInput 事件。区别之二是 textInput 事件只会在用户按下能够输入实际字符的键时才会触发，而 keypress 事件则在按下那些能够影响文本显示的键时也会触发(例如退格键)。</p>
<p>由于 textInput 主要考虑的是字符，因此它的 event 对象中还包含一个 data 属性，这个属性的值就是用户输入的字符(而非字符编码)。话句话说，用户在没有按上档键的情况下按下了S键，data 的值就是”s”,而如果在按住上档键时按下该键，data 的值就是”s”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var textbox = document.getElementById(&quot;myText&quot;);</div><div class="line">EventUtil.addHandler(textbox, &quot;textInput&quot;, function(event) &#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(event.data);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><h4 id="contextmenu-事件"><a href="#contextmenu-事件" class="headerlink" title="contextmenu 事件"></a>contextmenu 事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(window, &quot;load&quot;, function(event) &#123;</div><div class="line">    var div = document.getElementById(&apos;myDiv&apos;);</div><div class="line"></div><div class="line">    EventUtil.addHandler(div, &quot;contextmenu&quot;, function(event)&#123;</div><div class="line">        event = EventUtil.getEvent(event);</div><div class="line">        EventUtil.preventDefault(event);</div><div class="line"></div><div class="line">        var menu = document.getElementById(&apos;myMenu&apos;);</div><div class="line">        menu.style.left = event.clientX + &apos;px&apos;;</div><div class="line">        menu.style.top = event.clientY = &apos;px&apos;;</div><div class="line">        menu,style.visibility = &quot;visible&quot;;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    EventUtil.addHandler(document, &apos;click&apos;, function()&#123;</div><div class="line">        document.getElementById(&apos;myMenu&apos;).style.visibility = &apos;hidden&apos;;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="beforeunload-页面卸载前-事件"><a href="#beforeunload-页面卸载前-事件" class="headerlink" title="beforeunload(页面卸载前) 事件"></a>beforeunload(页面卸载前) 事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(window, &quot;beforeunload&quot;, function(event)&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    var message = &quot;I&apos;m really going to miss you if you go.&quot;;</div><div class="line">    event.returnValue = message;</div><div class="line">    return message;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="DOMContentLoaded-IE-9-事件"><a href="#DOMContentLoaded-IE-9-事件" class="headerlink" title="DOMContentLoaded(IE 9+) 事件"></a>DOMContentLoaded(IE 9+) 事件</h4><p>DOMContentLoaded 事件在形成完整的 DOM 树之后就会触发，不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(document, &quot;DOMContentLoaded&quot;, function(event)&#123;</div><div class="line">    alert(&apos;Content loaded&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a>readystatechange 事件</h4><p>readyState 属性： uninitialized|loading|loaded|interactive|complete</p>
<h3 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h3><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//一下面的 HTML 代码为例</div><div class="line">&lt;ul id=&quot;myLinks&quot;&gt;</div><div class="line">    &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt;</div><div class="line">    &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt;</div><div class="line">    &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">var list = document.getElementById(&apos;myLinks&apos;);</div><div class="line">EventUtil.addHandler(list, &quot;click&quot;, function(event)&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    var target = EventUtil.getTarget(event);</div><div class="line"></div><div class="line">    switch(target.id) &#123;</div><div class="line">        case &quot;doSomething&quot;:</div><div class="line">            document.title = &quot;I changed the document&apos;s title&quot;;</div><div class="line">            break;</div><div class="line"></div><div class="line">        case &quot;goSomewhere&quot;:</div><div class="line">            location.href = &apos;http://www.google.com&apos;;</div><div class="line">            break;</div><div class="line"></div><div class="line">        case &quot;sayHi&quot;:</div><div class="line">            alert(&quot;hi&quot;);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最适合采用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup、和keypress。虽然 moseover 和 mouseout 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。(因为当鼠标从一个元素移到其子节点时，或者当鼠标移出该元素时，都会触发 mouseout事件。)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/事件/">事件</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/jQuery源码分析/" title="jQuery源码分析" itemprop="url">jQuery源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.535Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><h2 id="自调用匿名函数"><a href="#自调用匿名函数" class="headerlink" title="自调用匿名函数"></a>自调用匿名函数</h2><h3 id="为什么要为自调用匿名函数设置参数window，并传入window-对象？"><a href="#为什么要为自调用匿名函数设置参数window，并传入window-对象？" class="headerlink" title="为什么要为自调用匿名函数设置参数window，并传入window 对象？"></a>为什么要为自调用匿名函数设置参数window，并传入window 对象？</h3><p>通过传入window 对象，可以使window 对象变为局部变量（即把函数参数作为局部<br>变量使用），这样当在jQuery 代码块中访问window 对象时，不需要将作用域链回退到顶<br>层作用域，从而可以更快地访问window 对象，这是原因之一；另外，将window 对象作<br>为参数传入，可以在压缩代码时进行优化，在压缩文件jquery-1.7.1.min.js 中可以看到下<br>面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(function(a,b)&#123; ... &#125;)(window);</div><div class="line">// 参数 window 被压缩为 a，参数 undefined 被压缩为 b</div></pre></td></tr></table></figure>
<h3 id="注意到自调用匿名函数最后的分号（-）了吗？"><a href="#注意到自调用匿名函数最后的分号（-）了吗？" class="headerlink" title="注意到自调用匿名函数最后的分号（;）了吗？"></a>注意到自调用匿名函数最后的分号（;）了吗？</h3><p>通常在JavaScript 中，如果语句分别放置在不同的行中，则分号（;）是可选的，但是对<br>于自调用匿名函数来说，在之前或之后省略分号都可能会引起语法错误。例如，执行下面的<br>两个例子，就会抛出异常。<br>例1　在下面的代码中，如果自调用匿名函数的前一行末尾没有加分号，则自调用匿名<br>函数的第一对括号会被当作是函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var n = 1</div><div class="line">( function()&#123;&#125; )()</div><div class="line">// TypeError: number is not a function</div></pre></td></tr></table></figure></p>
<p>例2　在下面的代码中，如果未在第一个自调用匿名函数的末尾加分号，则下一行自调<br>用匿名函数的第一对括号会被当作是函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">( function()&#123;&#125; )()</div><div class="line">( function()&#123;&#125; )()</div><div class="line">// TypeError: undefined is not a function</div></pre></td></tr></table></figure></p>
<p>所以，在使用自调用匿名函数时，最好不要省略自调用匿名函数之前和之后的分号。</p>
<h1 id="构造jQuery对象"><a href="#构造jQuery对象" class="headerlink" title="构造jQuery对象"></a>构造jQuery对象</h1><h2 id="构造函数jQuery"><a href="#构造函数jQuery" class="headerlink" title="构造函数jQuery()"></a>构造函数jQuery()</h2><h3 id="jQuery-selector-context"><a href="#jQuery-selector-context" class="headerlink" title="jQuery( selector [, context] )"></a>jQuery( selector [, context] )</h3><p>如果传入一个字符串参数，jQuery 会检查这个字符串是选择器表达式还是HTML 代<br>码。如果是选择器表达式，则遍历文档，查找与之匹配的DOM 元素，并创建一个包含了<br>这些DOM 元素引用的jQuery 对象；如果没有元素与之匹配，则创建一个空jQuery 对象，<br>其中不包含任何元素，其属性length 等于0。字符串参数是HTML 代码的情况会在下一小<br>节介绍。<br>默认情况下，对匹配元素的查找将从根元素document 对象开始，即查找范围是整个文<br>档树，不过也可以传入第二个参数context 来限定查找范围（本书中把参数context 称为“选<br>择器的上下文”，或简称“上下文”）。例如，在一个事件监听函数中，可以像下面这样限制<br>查找范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).click(function() &#123;</div><div class="line">    $(&apos;span&apos;, this).addClass(&apos;bar&apos;); // 限定查找范围</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在这个例子中，对选择器表达式“ span”的查找被限制在了this 的范围内，即只有被点<br>击元素内的span 元素才会被添加类样式“bar ”。<br>如果选择器表达式selector 是简单的“ #id”，且没有指定上下文context，则调用浏览器<br>原生方法document.getElementById() 查找属性id 等于指定值的元素；如果是比“ #id”复杂<br>的选择器表达式或指定了上下文，则通过jQuery 方法.find() 查找，因此$(‘span’, this) 等价<br>于$(this).find(‘span’)。<br>至于方法.find()，会调用CSS 选择器引擎Sizzle 实现</p>
<h3 id="jQuery-html-ownerDocument-、jQuery-html-props"><a href="#jQuery-html-ownerDocument-、jQuery-html-props" class="headerlink" title="　jQuery( html [, ownerDocument] )、jQuery( html, props )"></a>　jQuery( html [, ownerDocument] )、jQuery( html, props )</h3><p>如果传入的字符串参数看起来像一段HTML 代码（例如，字符串中含有<tag…>），<br>jQuery 则尝试用这段HTML 代码创建新的DOM 元素，并创建一个包含了这些DOM 元素引<br>用的jQuery 对象。例如，下面的代码将把HTML 代码转换成DOM 元素并插入body 节点的<br>末尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;&lt;p id=&quot;test&quot;&gt;My &lt;em&gt;new&lt;/em&gt; text&lt;/p&gt;&apos;).appendTo(&apos;body&apos;);</div></pre></td></tr></table></figure></tag…></p>
<p>如果HTML 代码是一个单独标签，例如，$(‘<img>‘) 或$(‘<a></a>‘)，jQuery 会使<br>用浏览器原生方法document.createElement() 创建DOM 元素。如果是比单独标签更复杂的<br>HTML 片段，例如上面例子中的$(‘</p><p id="test">My<em>new</em>text</p>‘)，则利用<br>浏览器的innerHTML 机制创建DOM 元素，这个过程由方法jQuery.buildFragment() 和方法<br>jQuery.clean() 实现。<p></p>
<p>第二个参数ownerDocument 用于指定创建新DOM 元素的文档对象，如果不传入，则默<br>认为当前文档对象。<br>如果HTML 代码是一个单独标签，那么第二个参数还可以是props，props 是一个包含了<br>属性、事件的普通对象；在调用document.createElement() 创建DOM 元素后，参数props 会被传给jQuery 方法.attr()，然后由.attr() 负责把参数props 中的属性、事件设置到新创建的<br>DOM 元素上。<br>参数props 的属性可以是任意的事件类型（如“ click”），此时属性值应该是事件监听<br>函数，它将被绑定到新创建的DOM 元素上；参数props 可以含有以下特殊属性：val、css、<br>html、text、data、width、height、offset，相应的jQuery 方法：.val()、.css()、.html()、.text()、.<br>data()、.width()、.height()、.offset() 将被执行，并且属性值会作为参数传入；其他类型的属性<br>则会被设置到新创建的DOM 元素上，某些特殊属性还会做跨浏览器兼容（如type、value、<br>tabindex 等）；可以通过属性名class 设置类样式，但要用引号把class 包裹起来，因为class<br>是JavaScript 保留字。例如，在下面的例子中，创建一个div 元素，并设置类样式为“ test ”、<br>设置文本内容为“ Click me!”、绑定一个click 事件，然后插入body 节点的末尾，当点击该<br>div 元素时，还会切换类样式test：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(&quot;&lt;div/&gt;&quot;, &#123;</div><div class="line">    &quot;class&quot;: &quot;test&quot;,</div><div class="line">    text: &quot;Click me!&quot;,</div><div class="line">    click: function()&#123;</div><div class="line">        $(this).toggleClass(&quot;test&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;).appendTo(&quot;body&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="jQuery-element-、jQuery-elementArray"><a href="#jQuery-element-、jQuery-elementArray" class="headerlink" title="jQuery( element )、jQuery( elementArray )"></a>jQuery( element )、jQuery( elementArray )</h3><p>如果传入一个DOM 元素或DOM元素数组，则把DOM 元素封装到jQuery 对象中并返回。<br>这个功能常见于事件监听函数，即把关键字this 引用的DOM 元素封装为jQuery 对象，<br>然后在该jQuery 对象上调用jQuery 方法。例如，在下面的例子中，先调用$(this) 把被点击<br>的div 元素封装为jQuery 对象，然后调用方法slideUp() 以滑动动画隐藏该div 元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).click(function() &#123;</div><div class="line">    $(this).slideUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>###　jQuery( object )<br>如果传入一个普通JavaScript 对象，则把该对象封装到jQuery 对象中并返回。<br>这个功能可以方便地在普通JavaScript 对象上实现自定义事件的绑定和触发，例如，执<br>行下面的代码会在对象foo 上绑定一个自定义事件custom，然后手动触发这个事件，执行绑<br>定的custom 事件监听函数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 定义一个普通 JavaScript 对象</div><div class="line">var foo = &#123;foo:&apos;bar&apos;, hello:&apos;world&apos;&#125;;</div><div class="line">// 封装成 jQuery 对象</div><div class="line">var $foo = $(foo);</div><div class="line">// 绑定一个事件</div><div class="line">$foo.on(&apos;custom&apos;, function ()&#123;</div><div class="line">console.log(&apos;custom event was called&apos;);</div><div class="line">&#125;);</div><div class="line">// 触发这个事件</div><div class="line">$foo.trigger(&apos;custom&apos;); // 在控制台打印&quot;custom event was called&quot;</div></pre></td></tr></table></figure></p>
<p>###　jQuery( callback )<br>如果传入一个函数，则在document 上绑定一个ready 事件监听函数，当DOM 结构加载<br>完成时执行。ready 事件的触发要早于load 事件。ready 事件并不是浏览器原生事件，而是<br>DOMContentLoaded 事件、onreadystatechange 事件和函数doScrollCheck() 的统称。</p>
<p>###　jQuery( jQuery object )<br>如果传入一个jQuery 对象，则创建该jQuery 对象的一个副本并返回，副本与传入的<br>jQuery 对象引用完全相同的DOM 元素。</p>
<p>###　jQuery()<br>如果不传入任何参数，则返回一个空的jQuery 对象，属性length 为0。注意，在jQuery<br>1.4 之前，会返回一个含有document 对象的jQuery 对象。<br>这个功能可以用来复用jQuery 对象，例如，创建一个空的jQuery 对象，然后在需要时<br>先手动修改其中的元素，再调用jQuery 方法，从而避免重复创建jQuery 对象。</p>
<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>构造jQuery 对象模块的总体源码结构如代码清单2-1 所示。</p>
<p>代码清单2-1　构造 jQuery 对象模块的总体源码结构</p>
<p><hr><br>16　(function( window, undefined ) {<br>// 构造 jQuery 对象<br>22　 var jQuery = (function() {<br>25　 var jQuery = function( selector, context ) {<br>27　 return new jQuery.fn.init( selector, context, root jQuery );<br>28　 },<br>// 一堆局部变量声明<br>97　 jQuery.fn = jQuery.prototype = {<br>98　 constructor: jQuery,<br>99　 init: function( selector, context, rootjQuery ) { … },<br>// 一堆原型属性和方法<br>319　 };<br>322　 jQuery.fn.init.prototype = jQuery.fn;<br>324　 jQuery.extend = jQuery.fn.extend = function() { … };<br>388　 jQuery.extend({<br>// 一堆静态属性和方法<br>892　 });<br>955　 return jQuery;<br>957 })();<br>// 省略其他模块的代码<br>9246　 window.jQuery = window.$ = jQuery;<br>9266　})( window );</p>
<p>下面简要梳理下这段源码。<br>第16 ～ 9266 行是最外层的自调用匿名函数，第1 章中介绍过，当jQuery 初始化时，这<br>个自调用匿名函数包含的所有JavaScript 代码将被执行。<br>第22 行定义了一个变量jQuery，第22 ～ 957 行的自调用匿名函数返回jQuery 构造函<br>数并赋值给变量jQuery，最后在第9246 行把这个jQuery 变量暴露给全局作用域window，并<br>定义了别名$。<br>在第22 ～ 957 行的自调用匿名函数内，第25 行又定义了一个变量jQuery，它的值是<br>jQuery 构造函数，在第955 行返回并赋值给第22 行的变量jQuery。因此，这两个jQuery 变<br>量是等价的，都指向jQuery 构造函数，为了方便描述，在后面中统一称为构造函数jQuery()。<br>第97 ～ 319 行覆盖了构造函数jQuery() 的原型对象。第98 行覆盖了原型对象的属性<br>constructor，使它指向jQuery 构造函数；第99 行定义了原型方法jQuery.fn.init()，它负责<br>解析参数selector 和context 的类型并执行相应的查找；在第27 行可以看到，当我们调用<br>jQuery 构造函数时，实际返回的是jQuery.fn.init() 的实例；此外，还定义了一堆其他的原型<br>属性和方法，例如，selector、length、size()、toArray() 等。<br>第322 行用jQuery 构造函数的原型对象jQuery.fn 覆盖了jQuery.fn.init() 的原型对象。<br>第324 行定义了jQuery.extend() 和jQuery.fn.extend()，用于合并两个或多个对象的属性<br>到第一个对象；第388 ～ 892 行执行jQuery.extend() 在jQuery 构造函数上定义了一堆静态属<br>性和方法，例如，noConflict()、isReady、readyWait、holdReady() 等。<br>看上去代码清单2-1 所述的总体源码结构有些复杂，下面把疑问和难点一一罗列，逐个分析。<br>1）为什么要在构造函数jQuery() 内部用运算符new 创建并返回另一个构造函数的实例？<br>通常我们创建一个对象或实例的方式是在运算符new 后紧跟一个构造函数，例如，<br>newDate() 会返回一个Date 对象；但是，如果构造函数有返回值，运算符new 所创建的对象<br>会被丢弃，返回值将作为new 表达式的值。<br>jQuery 利用了这一特性，通过在构造函数jQuery() 内部用运算符new 创建并返回另一个<br>构造函数的实例，省去了构造函数jQuery() 前面的运算符new，即我们创建jQuery 对象时，<br>可以省略运算符new 直接写jQuery()。<br>为了拼写更方便，在第9246 行还为构造函数jQuery() 定义了别名$，因此，创建jQuery<br>对象的常见写法是$()。<br>2）为什么在第97 行执行jQuery.fn = jQuery.prototype，设置jQuery.fn 指向构造函数<br>jQuery() 的原型对象jQuery.prototype ？<br>jQuery.fn 是jQuery.prototype 的简写，可以少写7 个字符，以方便拼写。<br>3）既然调用构造函数jQuery() 返回的jQuery 对象实际上是构造函数jQuery.fn.init() 的<br>实例，为什么能在构造函数jQuery.fn.init() 的实例上调用构造函数jQuery() 的原型方法和属<br>性？例如，$(‘#id’).length 和$(‘#id’).size()。<br>在第322 行执行jQuery.fn.init.prototype = jQuery.fn 时，用构造函数jQuery() 的原型对象<br>覆盖了构造函数jQuery.fn.init() 的原型对象，从而使构造函数jQuery.fn.init() 的实例也可以访<br>问构造函数jQuery() 的原型方法和属性。<br>4）为什么要把第25 ～ 955 行的代码包裹在一个自调用匿名函数中，然后把第25 行定<br>义的构造函数jQuery() 作为返回值赋值给第22 行的jQuery 变量？去掉这个自调用匿名函<br>数，直接在第25 行定义构造函数jQuery() 不也可以吗？去掉了不是更容易阅读和理解吗？<br>去掉第25 ～ 955 行的自调用匿名函数当然可以，但会潜在地增加构造jQuery 对象模块<br>与其他模块的耦合度。在第25 ～ 97 行之间还定义了很多其他的局部变量，这些局部变量只<br>在构造jQuery 对象模块内部使用。通过把这些局部变量包裹在一个自调用匿名函数中，实现<br>了高内聚低耦合的设计思想。<br>5）为什么要覆盖构造函数jQuery() 的原型对象jQuery.prototype ？<br>在原型对象jQuery.prototype 上定义的属性和方法会被所有jQuery 对象继承，可以有<br>效减少每个jQuery 对象所需的内存。事实上，jQuery 对象只包含5 种非继承属性，其余都<br>继承自原型对象jQuery.prototype ；在构造函数jQuery.fn.init() 中设置了整型属性、length、<br>selector、context ；在原型方法.pushStack() 中设置了prevObject。因此，也不必因为jQuery<br>对象带有太多的属性和方法而担心会占用太多的内存。</p>
<h2 id="jQuery-fn-init-selector-context-rootjQuery"><a href="#jQuery-fn-init-selector-context-rootjQuery" class="headerlink" title="jQuery.fn.init( selector, context, rootjQuery )"></a>jQuery.fn.init( selector, context, rootjQuery )</h2><h3 id="12-个分支"><a href="#12-个分支" class="headerlink" title="12 个分支"></a>12 个分支</h3><p>构造函数jQuery.fn.init() 负责解析参数selector 和context 的类型，并执行相应的逻辑，最<br>后返回jQuery.fn.init() 的实例。参数selector 和context 共有12 个有效分支，如表2-1 所示。</p>
<p>表2-1　参数selector 和context 的12 个分支<br><img src="img/blog/table2_1.png"><br><img src="img/blog/table2_1x.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="img/blog/table2_4.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/作用域和闭包/" title="作用域和闭包" itemprop="url">作用域和闭包</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.535Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="实质问题"><a href="#实质问题" class="headerlink" title="实质问题"></a>实质问题</h3><p>下面用一些代码来解释这个定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    var a = 2;</div><div class="line">    function bar() &#123;</div><div class="line">        console.log( a ); // 2</div><div class="line">    &#125;</div><div class="line">    bar();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数bar()可以<br>访问外部作用域中的变量a（这个例子中的是一个RHS引用查询）。<br>这是闭包吗？<br>技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释bar()对a的<br>引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部<br>分！）</p>
<p>从纯学术的角度说，在上面的代码片段中，函数bar()具有一个涵盖foo()作用域的闭包（事实上，涵<br>盖了它能访问的所有作用域，比如全局作用域）。也可以认为bar()被封闭在了foo()的作用域中。为<br>什么呢？原因简单明了，因为bar()嵌套在foo()内部。<br>但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是如何工<br>作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易<br>理解。<br>下面我们来看一段代码，清晰地展示了闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    var a = 2;</div><div class="line">    function bar() &#123;</div><div class="line">        console.log( a );</div><div class="line">    &#125;</div><div class="line">    return bar;</div><div class="line">&#125;</div><div class="line">var baz = foo();</div><div class="line">baz(); // 2 ———— 朋友，这就是闭包的效果。</div></pre></td></tr></table></figure></p>
<p>函数bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当作一个值类型<br>进行传递。在这个例子中，我们将bar所引用的函数对象本身当作返回值。<br>在foo()执行后，其返回值（也就是内部的bar()函数）赋值给变量baz并调用baz()，实际上只是通过<br>不同的标识符引用调用了内部的函数bar()。<br>bar()显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。<br>在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用<br>来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进<br>行回收。<br>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回<br>收。谁在使用这个内部作用域？原来是bar()本身在使用。<br>拜bar()所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以<br>供bar()在之后任何时间进行引用。<br>bar()依然持有对该作用域的引用，而这个引用就叫作闭包。<br>因此，在几微秒之后变量baz被实际调用（调用内部函数bar），不出意料它可以访问定义时的词法<br>作用域，因此它也可以如预期般访问变量a。<br>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作<br>用域。<br>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function baz() &#123;</div><div class="line">    console.log( a ); // 2</div><div class="line">&#125;</div><div class="line">bar( baz );</div><div class="line">&#125;</div><div class="line">function bar(fn) &#123;</div><div class="line">    fn(); // 妈妈快看呀，这就是闭包！</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把内部函数baz传递给bar，当调用这个内部函数时（现在叫作fn），它涵盖的foo()内部作用域的闭<br>包就可以观察到了，因为它能够访问a。<br>传递函数当然也可以是间接的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var fn;</div><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function baz() &#123;</div><div class="line">    console.log( a );</div><div class="line">&#125;</div><div class="line">fn = baz; // 将baz分配给全局变量</div><div class="line">&#125;</div><div class="line">function bar() &#123;</div><div class="line">    fn(); // 妈妈快看呀，这就是闭包！</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">bar(); // 2</div></pre></td></tr></table></figure></p>
<p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引<br>用，无论在何处执行这个函数都会使用闭包。</p>
<p>本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类<br>型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通<br>信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使<br>用闭包！</p>
<blockquote>
<p>通常认为IIFE是典型的闭包例子，但根据先前对闭包的定义，我并<br>不是很同意这个观点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line">(function IIFE() &#123;</div><div class="line">    console.log( a );</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的IIFE）并<br>不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是<br>全局作用域也持有a）。a是通过普通的词法作用域查找而非闭包被发现的。<br>尽管技术上来讲，闭包是发生在定义时的，但并不非常明显，就好像六祖慧能所说：”既非风动，亦<br>非幡动，仁者心动耳。”</p>
<p>尽管IIFE本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被<br>封闭起来的闭包的工具。因此IIFE的确同闭包息息相关，即使本身并不会真的使用闭包。</p>
<h3 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h3><p>要说明闭包，for循环是最常见的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">    setTimeout( function timer() &#123;</div><div class="line">        console.log( i );</div><div class="line">    &#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正常情况下，我们对这段代码行为的预期是分别输出数字1~5，每秒一次，每次一个。<br>但实际上，这段代码在运行时会以每秒一次的频率输出五次6。<br>这是为什么？<br>首先解释6是从哪里来的。这个循环的终止条件是i不再&lt;=5。条件首次成立时i的值是6。因此，输出<br>显示的是循环结束时i的最终值。<br>仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，当定时器<br>运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被<br>执行，因此会每次输出一个6出来。<br>这里引伸出一个更深入的问题，代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？<br>缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是根据作用域<br>的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭<br>在一个共享的全局作用域中，因此实际上只有一个i。<br>下面回到正题。缺陷是什么？我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要<br>一个闭包作用域。<br>IIFE会通过声明并立即执行一个函数来创建作用域。<br>我们来试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">(function() &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( i );</div><div class="line">&#125;, i*1000 );</div><div class="line">&#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>。这样不行。但是为什么呢？我们现在显然拥有更多的词法作用域了。的确每个延迟<br>函数都会将IIFE在每次迭代中创建的作用域封闭起来。<br>如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的IIFE只是一个什么都<br>没有的空作用域。它需要包含一点实质内容才能为我们所用。<br>它需要有自己的变量，用来在每个迭代中储存i的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">    (function() &#123;</div><div class="line">        var j = i;</div><div class="line">        setTimeout( function timer() &#123;</div><div class="line">            console.log( j );</div><div class="line">        &#125;, j*1000 );</div><div class="line">    &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行了！它能正常工作了！。<br>可以对这段代码进行一些改进：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">    (function(j) &#123;</div><div class="line">        setTimeout( function timer() &#123;</div><div class="line">            console.log( j );</div><div class="line">        &#125;, j*1000 );</div><div class="line">    &#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>let声明，可以用来劫持块作用域，并且<br>在这个块作用域中声明一个变量。<br>本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面这些看起来很酷的代码就可以<br>正常运行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">    let j = i; // 是的，闭包的块作用域！</div><div class="line">    setTimeout( function timer() &#123;</div><div class="line">        console.log( j );</div><div class="line">    &#125;, j*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是，这还不是全部！for循环头部的let声明还会有一个特殊的行<br>为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使<br>用上一个迭代结束时的值来初始化这个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (let i=1; i&lt;=5; i++) &#123;</div><div class="line">    setTimeout( function timer() &#123;</div><div class="line">        console.log( i );</div><div class="line">    &#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究<br>其中最强大的一个：模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    var something = &quot;cool&quot;;</div><div class="line">    var another = [1, 2, 3];</div><div class="line">    function doSomething() &#123;</div><div class="line">        console.log( something );</div><div class="line">    &#125;</div><div class="line">    function doAnother() &#123;</div><div class="line">        console.log( another.join( &quot; ! &quot; ) );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如在这段代码中所看到的，这里并没有明显的闭包，只有两个私有数据变量something<br>和another，以及doSomething()和doAnother()两个内部函数，它们的词法作用域（而这就是闭包）也<br>就是foo()的内部作用域。<br>接下来考虑以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function CoolModule() &#123;</div><div class="line">    var something = &quot;cool&quot;;</div><div class="line">    var another = [1, 2, 3];</div><div class="line">    function doSomething() &#123;</div><div class="line">        console.log( something );</div><div class="line">    &#125;</div><div class="line">    function doAnother() &#123;</div><div class="line">        console.log( another.join( &quot; ! &quot; ) );</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        doSomething: doSomething,</div><div class="line">        doAnother: doAnother</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var foo = CoolModule();</div><div class="line">foo.doSomething(); // cool</div><div class="line">foo.doAnother(); // 1 ! 2 ! 3</div></pre></td></tr></table></figure></p>
<p>这个模式在JavaScript中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展<br>示的是其变体。<br>我们仔细研究一下这些代码。<br>首先，CoolModule()只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，<br>内部作用域和闭包都无法被创建。<br>其次，CoolModule()返回一个用对象字面量语法{ key: value, … }来表示的对象。这个返回的对<br>象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。<br>可以将这个对象类型的返回值看作本质上是模块的公共API。<br>这个对象类型的返回值最终被赋值给外部的变量foo，然后就可以通过它来访问API中的属性方<br>法，比如foo.doSomething()。</p>
<p>doSomething()和doAnother()函数具有涵盖模块实例内部作用域的闭包（通过调用CoolModule()实<br>现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创<br>造了可以观察和实践闭包的条件。<br>如果要更简单的描述，模块模式需要具备两个必要条件。</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以<br>访问或者修改私有的状态。<br>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回<br>的，只有数据属性而没有闭包函数的对象并不是真正的模块。<br>上一个示例代码中有一个叫作CoolModule()的独立的模块创建器，可以被调用任意多次，每次调用<br>都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现单例<br>模式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var foo = (function CoolModule() &#123;</div><div class="line">    var something = &quot;cool&quot;;</div><div class="line">    var another = [1, 2, 3];</div><div class="line">    function doSomething() &#123;</div><div class="line">        console.log( something );</div><div class="line">    &#125;</div><div class="line">    function doAnother() &#123;</div><div class="line">        console.log( another.join( &quot; ! &quot; ) );</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        doSomething: doSomething,</div><div class="line">        doAnother: doAnother</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line">foo.doSomething(); // cool</div><div class="line">foo.doAnother(); // 1 ! 2 ! 3</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我们将模块函数转换成了IIFE，立即调用这个函数并将返回值直接赋值给单例的模<br>块实例标识符foo。<br>模块也是普通的函数，因此可以接受参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function CoolModule(id) &#123;</div><div class="line">    function identify() &#123;</div><div class="line">    console.log( id );</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        identify: identify</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var foo1 = CoolModule( &quot;foo 1&quot; );</div><div class="line">var foo2 = CoolModule( &quot;foo 2&quot; );</div><div class="line">foo1.identify(); // &quot;foo 1&quot;</div><div class="line">foo2.identify(); // &quot;foo 2&quot;</div></pre></td></tr></table></figure></p>
<p>模块模式另一个简单但强大的变化用法是，命名将要作为公共API返回的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var foo = (function CoolModule(id) &#123;</div><div class="line">    function change() &#123;</div><div class="line">    // 修改公共API</div><div class="line">    publicAPI.identify = identify2;</div><div class="line">    &#125;</div><div class="line">    function identify1() &#123;</div><div class="line">        console.log( id );</div><div class="line">    &#125;</div><div class="line">    function identify2() &#123;</div><div class="line">        console.log( id.toUpperCase() );</div><div class="line">    &#125;</div><div class="line">    var publicAPI = &#123;</div><div class="line">        change: change,</div><div class="line">        identify: identify1</div><div class="line">    &#125;;</div><div class="line">    return publicAPI;</div><div class="line">&#125;)( &quot;foo module&quot; );</div><div class="line">foo.identify(); // foo module</div><div class="line">foo.change();</div><div class="line">foo.identify(); // FOO MODULE</div></pre></td></tr></table></figure></p>
<p>通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添<br>加或删除方法和属性，以及修改它们的值。</p>
<p>大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var MyModules = (function Manager() &#123;</div><div class="line">    var modules = &#123;&#125;;</div><div class="line">    function define(name, deps, impl) &#123;</div><div class="line">        for (var i=0; i&lt;deps.length; i++) &#123;</div><div class="line">            deps[i] = modules[deps[i]];</div><div class="line">        &#125;</div><div class="line">    modules[name] = impl.apply( impl, deps );</div><div class="line">    &#125;</div><div class="line">    function get(name) &#123;</div><div class="line">        return modules[name];</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        define: define,</div><div class="line">        get: get</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>这段代码的核心是modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装函数（可<br>以传入任何依赖），并且将返回值，也就是模块的API，储存在一个根据名字来管理的模块列表中。<br>下面展示了如何使用它来定义模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">MyModules.define( &quot;bar&quot;, [], function() &#123;</div><div class="line">    function hello(who) &#123;</div><div class="line">    return &quot;Let me introduce: &quot; + who;</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        hello: hello</div><div class="line">    &#125;;</div><div class="line">&#125; );</div><div class="line">MyModules.define( &quot;foo&quot;, [&quot;bar&quot;], function(bar) &#123;</div><div class="line">    var hungry = &quot;hippo&quot;;</div><div class="line">    function awesome() &#123;</div><div class="line">        console.log( bar.hello( hungry ).toUpperCase() );</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        awesome: awesome</div><div class="line">    &#125;;</div><div class="line">&#125; );</div><div class="line">var bar = MyModules.get( &quot;bar&quot; );</div><div class="line">var foo = MyModules.get( &quot;foo&quot; );</div><div class="line">console.log(</div><div class="line">bar.hello( &quot;hippo&quot; )</div><div class="line">); // &lt;i&gt;Let me introduce: hippo&lt;/i&gt;</div><div class="line">foo.awesome(); // LET ME INTRODUCE: HIPPO</div></pre></td></tr></table></figure></p>
<p>“foo”和”bar”模块都是通过一个返回公共API的函数来定义的。”foo”甚至接受”bar”的示例作为依<br>赖参数，并能相应地使用它。<br>要理解模块管理器没有任何特殊的“魔力”。它们符合前面列出的模块模式的两个特点：为函数定义<br>引入包装函数，并保证它的返回值和模块的API保持一致。<br>换句话说，模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/Type-Grammar/">Type & Grammar</a><a href="/tags/闭包/">闭包</a><a href="/tags/模块/">模块</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/作用域是什么/" title="作用域是什么" itemprop="url">作用域是什么</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.535Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><h4 id="RHS-LHS"><a href="#RHS-LHS" class="headerlink" title="RHS LHS"></a>RHS LHS</h4><p>它们分别代表左侧和右侧。<br>什么东西的左侧和右侧？是一个赋值操作的左侧和右侧。<br>换句话说，当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。<br>讲得更准确一点，RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量<br>的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的“赋值操作的右侧”，更准<br>确地说是“非左侧”。<br>你可以将RHS理解成retrieve his source value（取到它的源值），这意味着“得到某某的值”。</p>
<p>考虑以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log( a );</div></pre></td></tr></table></figure>
<p>其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值。相应地，需要查找并取得a的值，这<br>样才能将值传递给console.log(..)。<br>相比之下，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = 2;</div></pre></td></tr></table></figure>
<p>这里对a的引用则是LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为= 2这个赋<br>值操作找到一个目标。</p>
<blockquote>
<p>LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧<br>或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁<br>（LHS）”以及“谁是赋值操作的源头（RHS）”。</p>
</blockquote>
<p>考虑下面的程序，其中既有LHS也有RHS引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">    console.log( a ); // 2</div><div class="line">&#125;</div><div class="line">foo( 2 );</div></pre></td></tr></table></figure>
<p>最后一行foo(..)函数的调用需要对foo进行RHS引用，意味着“去找到foo的值，并把它给我”。并<br>且(..)意味着foo的值需要被执行，因此它最好真的是一个函数类型的值！<br>这里还有一个容易被忽略却非常重要的细节。<br>代码中隐式的a = 2操作可能很容易被你忽略掉。这个操作发生在2被当作参数传递给foo(..)函数<br>时，2会被分配给参数a。为了给参数a（隐式地）分配值，需要进行一次LHS查询。<br>这里还有对a进行的RHS引用，并且将得到的值传给了console.log(..)。console.log(..)本身也需<br>要一个引用才能执行，因此会对console对象进行RHS查询，并且检查得到的值中是否有一个叫<br>作log的方法。<br>最后，在概念上可以理解为在LHS和RHS之间通过对值2进行交互来将其传递进log(..)（通过变<br>量a的RHS查询）。假设在log(..)函数的原生实现中它可以接受参数，在将2赋值给其中第一个（也<br>许叫作arg1）参数之前，这个参数需要进行LHS引用查询。</p>
<blockquote>
<p>你可能会倾向于将函数声明function foo(a) {…概念化为普通的变量声明和赋值，比<br>如var foo、foo ＝ function(a) {…。如果这样理解的话，这个函数声明将需要进行LHS查询。<br>然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引<br>擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。因此，将函数声明理解成前<br>面讨论的LHS查询和赋值的形式并不合适。</p>
</blockquote>
<h4 id="引擎和作用域的对话"><a href="#引擎和作用域的对话" class="headerlink" title="引擎和作用域的对话"></a>引擎和作用域的对话</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">    console.log( a ); // 2</div><div class="line">&#125;</div><div class="line">foo( 2 );</div></pre></td></tr></table></figure>
<p>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。</p>
<blockquote>
<p>引擎：我说作用域，我需要为foo进行RHS引用。你见过它吗？<br>作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎：哥们太够意思了！好吧，我来执行一下foo。<br>引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？<br>作用域：这个也见过，编译器最近把它声名为foo的一个形式参数了，拿去吧。<br>引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给a。<br>引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗？<br>作用域：咱俩谁跟谁啊，再说我就是干这个的。这个我也有，console是个内置对象。给你。<br>引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。<br>引擎：哥们，能帮我再找一下对a的RHS引用吗？虽然我记得它，但想再确认一次。<br>作用域：放心吧，这个变量没有变动过，拿走，不谢。<br>引擎：真棒。我来把a的值，也就是2，传递进log(..)。<br>……</p>
</blockquote>
<h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p>作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个作用域。<br>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法<br>找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作<br>用域（也就是全局作用域）为止。</p>
<p>考虑以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">    console.log( a + b );</div><div class="line">&#125;</div><div class="line">var b = 2;</div><div class="line">foo( 2 ); // 4</div></pre></td></tr></table></figure>
<p>对b进行的RHS引用无法在函数foo内部完成，但可以在上一级作用域（在这个例子中就是全局作<br>用域）中完成。<br>因此，回顾一下引擎和作用域之间的对话，会进一步听到：</p>
<blockquote>
<p>引擎：foo的作用域兄弟，你见过b吗？我需要对它进行RHS引用。<br>作用域：听都没听过，走开。<br>引擎：foo的上级作用域兄弟，咦？有眼不识泰山，原来你是全局作用域大哥，太好了。你见过b<br>吗？我需要对它进行RHS引用。<br>作用域：当然了，给你吧。</p>
</blockquote>
<p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一<br>级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>为什么区分LHS和RHS是一件重要的事情？<br>因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一<br>样的。</p>
<p>考虑如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">    console.log( a + b );</div><div class="line">b = a;</div><div class="line">&#125;</div><div class="line">foo( 2 );</div></pre></td></tr></table></figure>
<p>第一次对b进行RHS查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何<br>相关的作用域中都无法找到它。<br>如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。值<br>得注意的是，ReferenceError是非常重要的异常类型。<br>相较之下，当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域<br>中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。<br>“不，这个变量之前并不存在，但是我很热心地帮你创建了一个。”<br>ES5中引入了“严格模式”。同正常模式，或者说宽松/懒惰模式相比，严格模式在行为上有很多不<br>同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中LHS查<br>询失败时，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError<br>异常。<br>接下来，如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图<br>对一个非函数类型的值进行函数调用，或着引用null或undefined类型的值中的属性，那么引擎会<br>抛出另外一种类型的异常，叫作TypeError。<br>ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作<br>是非法或不合理的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行<br>赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。<br>赋值操作符会导致LHS查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值<br>操作。<br>JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2这样的声明会被分<br>解成两个独立的步骤：</p>
<ol>
<li>首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>
<li>接下来，a = 2会查询（LHS查询）变量a并对其进行赋值。<br>LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识<br>符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局<br>作用域（顶层），无论找到或没找到都将停止。<br>不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个<br>全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常<br>（严格模式下）。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/Type-Grammar/">Type & Grammar</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/15/关于this/" title="关于this" itemprop="url">关于this</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2017-04-15T07:43:25.535Z" itemprop="datePublished"> 发表于 2017-04-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="指向自身"><a href="#指向自身" class="headerlink" title="指向自身"></a>指向自身</h3><p>使用foo标识符替代this来引用函数对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo(num) &#123;</div><div class="line">    console.log( &quot;foo: &quot; + num );</div><div class="line">    // 记录foo被调用的次数</div><div class="line">    foo.count++;</div><div class="line">&#125;</div><div class="line">foo.count = 0</div><div class="line">var i;</div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">    if (i &gt; 5) &#123;</div><div class="line">        foo( i );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// foo: 6</div><div class="line">// foo: 7</div><div class="line">// foo: 8</div><div class="line">// foo: 9</div><div class="line">// foo被调用了多少次？</div><div class="line">console.log( foo.count ); // 4</div></pre></td></tr></table></figure></p>
<p>然而，这种方法同样回避了this的问题，并且完全依赖于变量foo的词法作用域。<br>另一种方法是强制this指向foo函数对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function foo(num) &#123;</div><div class="line">    console.log( &quot;foo: &quot; + num );</div><div class="line">    // 记录foo被调用的次数</div><div class="line">    // 注意，在当前的调用方式下（参见下方代码），this确实指向foo</div><div class="line">    this.count++;</div><div class="line">&#125;</div><div class="line">foo.count = 0;</div><div class="line">var i;</div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">    if (i &gt; 5) &#123;</div><div class="line">        // 使用call(..)可以确保this指向函数对象foo本身</div><div class="line">        foo.call( foo, i );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// foo: 6</div><div class="line">// foo: 7</div><div class="line">// foo: 8</div><div class="line">// foo: 9</div><div class="line">// foo被调用了多少次？</div><div class="line">console.log( foo.count ); // 4</div></pre></td></tr></table></figure></p>
<h3 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h3><p>this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时<br>的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在<br>哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在<br>函数执行的过程中用到。</p>
<p><b>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</b></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/Type-Grammar/">Type & Grammar</a><a href="/tags/this/">this</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/2/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="YLJ77" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/CSS/" title="CSS">CSS<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>25</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript-设计模式/" title="JavaScript 设计模式">JavaScript 设计模式<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/涉及底层/" title="涉及底层">涉及底层<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/js/" title="js">js<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Type-Grammar/" title="Type &amp; Grammar">Type &amp; Grammar<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Pro-JavaScript-Design-Patterns/" title="Pro JavaScript Design Patterns">Pro JavaScript Design Patterns<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Javascript-Ninja/" title="Javascript_Ninja">Javascript_Ninja<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Introduction-to-Algorithms/" title="Introduction to Algorithms">Introduction to Algorithms<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/this/" title="this">this<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/闭包/" title="闭包">闭包<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/DOM/" title="DOM">DOM<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/函数/" title="函数">函数<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/对象/" title="对象">对象<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/调试/" title="调试">调试<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/事件/" title="事件">事件<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/BOM/" title="BOM">BOM<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/underscore/" title="underscore">underscore<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/DOM3/" title="DOM3">DOM3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/DOM2/" title="DOM2">DOM2<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/响应式/" title="响应式">响应式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/媒体查询/" title="媒体查询">媒体查询<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/函数表达式/" title="函数表达式">函数表达式<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://http:YLJ77.github.io" target="_blank" title="lin&#39;s Blog">lin&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m linjie Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/YLJ77" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:linjieyang77@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/by-nc/4.0" class="cc-opacity" target="_blank">
            <img src="/img/cc-by-nc.svg" alt="Creative Commons" />
          </a>
        </div>
    

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="YLJ77">YLJ77</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
