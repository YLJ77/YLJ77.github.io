
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>fire on the world!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="YLJ77">
    

    
    <meta name="description" content="学习总结与感悟">
<meta property="og:type" content="website">
<meta property="og:title" content="fire on the world!">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="fire on the world!">
<meta property="og:description" content="学习总结与感悟">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fire on the world!">
<meta name="twitter:description" content="学习总结与感悟">

    
    <link rel="alternative" href="/atom.xml" title="fire on the world!" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="fire on the world!" title="fire on the world!"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="fire on the world!">fire on the world!</a></h1>
				<h2 class="blog-motto">try to take over the world</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/04/媒体查询/" title="媒体查询" itemprop="url">媒体查询</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-05-04T11:35:09.233Z" itemprop="datePublished"> 发表于 2016-05-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="媒体查询语法"><a href="#媒体查询语法" class="headerlink" title="媒体查询语法"></a>媒体查询语法</h3><p>纵向媒体查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; meida=&quot;screen and (orientation:portrait)&quot; href=&quot;portrait-screen.css&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在媒体查询的开头追加not则会颠倒查询的逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; meida=&quot;not screen and (orientation:portrait)&quot; href=&quot;portrait-screen.css&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>限制视口宽度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; meida=&quot;not screen and (orientation:portrait) and (min-width:800px)&quot; href=&quot;portrait-screen.css&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>CSS样式表中使用媒体查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-device-width: 400px) &#123;</span><br><span class="line">    h1 &#123; color: green&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用CSS的@import指令在当前样式表中按条件引入其他样式表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import url(&quot;phone.css&quot;) screen and (max-width:360px);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用CSS的@import方式会增加HTTP请求(这会影响加载速度)，要谨慎使用。</p>
</blockquote>
<h3 id="媒体查询特性"><a href="#媒体查询特性" class="headerlink" title="媒体查询特性"></a>媒体查询特性</h3><p>视口宽度: width<br>屏幕宽度: device-width</p>
<pre><code>
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/CSS/">CSS</a><a href="/tags/响应式/">响应式</a><a href="/tags/媒体查询/">媒体查询</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/04/随机取整/" title="随机取整" itemprop="url">随机取整</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-05-04T03:02:27.746Z" itemprop="datePublished"> 发表于 2016-05-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fnRand(m,n) &#123;</span><br><span class="line">    var r = Math.round(Math.random()*(n-m) + m);</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/随机数/">随机数</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/01/事件/" title="事件" itemprop="url">事件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-05-01T09:41:48.309Z" itemprop="datePublished"> 发表于 2016-05-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil = &#123;</span><br><span class="line">        //跨浏览器的事件处理程序</span><br><span class="line">        addHandler: function(element, type, handler) &#123;</span><br><span class="line">            if (element.addEventListener) &#123;</span><br><span class="line">                element.addEventListener(type, handler, false);</span><br><span class="line">            &#125; else if (element.attachEvent) &#123;</span><br><span class="line">                element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                element[&quot;on&quot; + type] = handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        removeHandler: function(element, type, handler) &#123;</span><br><span class="line">            if (element.removeEventListener) &#123;</span><br><span class="line">                element.removeEventListener(type, handler, false);</span><br><span class="line">            &#125; else if (element.detachEvent) &#123;</span><br><span class="line">                element.detachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                element[&quot;on&quot; + type] = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        //跨浏览器的事件对象</span><br><span class="line">        getEvent: function(event) &#123;</span><br><span class="line">            return event ? event : window.event;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        getTarget: function(event) &#123;</span><br><span class="line">            return event.target || event.srcElement;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        preventDefault: function(event) &#123;</span><br><span class="line">            if (event.preventDefault) &#123;</span><br><span class="line">                event.preventDefault();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                event.returnValue = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        stopPropagation: function(event) &#123;</span><br><span class="line">            if (event.stopPropagation) &#123;</span><br><span class="line">                event.stopPropagation();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                event.cancelBubble = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        //跨浏览器取得相关元素</span><br><span class="line">        getRelatedTarget: function(event) &#123;</span><br><span class="line">            if (event.relatedTarget) &#123;</span><br><span class="line">                return event.relatedTarget;</span><br><span class="line">            &#125; else if (event.toElement) &#123;</span><br><span class="line">                return event.toElement;</span><br><span class="line">            &#125; else if (event.fromElement) &#123;</span><br><span class="line">                return event.fromElement;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        //鼠标按钮</span><br><span class="line">        getButton: function(event) &#123;</span><br><span class="line">            if (document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;)) &#123;</span><br><span class="line">                return event.button;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                switch(event.button) &#123;</span><br><span class="line">                    case 0:</span><br><span class="line">                    case 1:</span><br><span class="line">                    case 3:</span><br><span class="line">                    case 5:</span><br><span class="line">                    case 7:</span><br><span class="line">                        return 0;</span><br><span class="line">                    case 2:</span><br><span class="line">                    case 6:</span><br><span class="line">                        return 2;</span><br><span class="line">                    case 4:</span><br><span class="line">                        return 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        //重新滚轮事件</span><br><span class="line">        getWheelDelta: function(event) &#123;</span><br><span class="line">            if (event.wheelDelta) &#123;</span><br><span class="line">                return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return -event.detail * 40;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        //字符编码</span><br><span class="line">        getCharCode: function(event) &#123;</span><br><span class="line">            if (typeof event.charCode == &quot;number&quot;) &#123;</span><br><span class="line">                return event.charCode;    //只有在发生keypress事件才包含值</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return event.keyCode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> //跨浏览器的事件处理程序示例：</span><br><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">var handler = function()&#123;</span><br><span class="line">    alert(&quot;Clicked&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">EventUtil.addHandler(btn, &quot;click&quot;, handler);</span><br><span class="line"></span><br><span class="line">//这里省略其它代码</span><br><span class="line"></span><br><span class="line">EventUtil.removeHandler(btn, &quot;click&quot;, handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//跨浏览器取得相关元素示例：</span><br><span class="line">var div = document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">EventUtil.addHandler(div, &quot;mouseout&quot;, function(event)&#123;</span><br><span class="line">    event = Event.getEvent(event);</span><br><span class="line">    var target = EventUtil.getTarget(event);</span><br><span class="line">    var relatedTarget = EventUtil.getRelatedTarget(event);</span><br><span class="line">    alert(&quot;Moused out fo &quot; + target.tagName + &quot; to &quot; + relatedTarget.tagName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><h4 id="客户区坐标位置"><a href="#客户区坐标位置" class="headerlink" title="客户区坐标位置"></a>客户区坐标位置</h4><p>可以使用类似下列代码取得鼠标事件的客户端坐标信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var div = document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">EventUtil.addHandler(div, &quot;click&quot;, function(event)&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(&quot;Client coordinates: &quot; + event.clientX + &quot;,&quot; + event.clientY);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="修改键"><a href="#修改键" class="headerlink" title="修改键"></a>修改键</h4><p>当某个鼠标事件发生时，通过检测这几个属性就可以确定用户是否同时按下了其中的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var div = document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">EventUtil.addHandler(div, &quot;click&quot;, function(event)&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    var keys = new Array();</span><br><span class="line"></span><br><span class="line">    if (event.shiftKey) &#123;</span><br><span class="line">        keys.push(&quot;shift&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (event.ctrlKey) &#123;</span><br><span class="line">        keys.push(&quot;ctrlKey&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (event.altKey) &#123;</span><br><span class="line">        keys.push(&quot;altKey&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (event.metaKey) &#123;</span><br><span class="line">        keys.push(&quot;metaKey&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    alert(&quot;Keys: &quot; + keys.join(&quot;,&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><h4 id="textInput-事件"><a href="#textInput-事件" class="headerlink" title="textInput 事件"></a>textInput 事件</h4><p>这个用于替代 keypress 的textInput 事件的行为稍有不同。区别之一就是任何可以获得焦点的元素都可以触发 keypress 事件，但只有可编辑区域才能触发 textInput 事件。区别之二是 textInput 事件只会在用户按下能够输入实际字符的键时才会触发，而 keypress 事件则在按下那些能够影响文本显示的键时也会触发(例如退格键)。</p>
<p>由于 textInput 主要考虑的是字符，因此它的 event 对象中还包含一个 data 属性，这个属性的值就是用户输入的字符(而非字符编码)。话句话说，用户在没有按上档键的情况下按下了S键，data 的值就是”s”,而如果在按住上档键时按下该键，data 的值就是”s”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var textbox = document.getElementById(&quot;myText&quot;);</span><br><span class="line">EventUtil.addHandler(textbox, &quot;textInput&quot;, function(event) &#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(event.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><h4 id="contextmenu-事件"><a href="#contextmenu-事件" class="headerlink" title="contextmenu 事件"></a>contextmenu 事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(window, &quot;load&quot;, function(event) &#123;</span><br><span class="line">    var div = document.getElementById(&apos;myDiv&apos;);</span><br><span class="line"></span><br><span class="line">    EventUtil.addHandler(div, &quot;contextmenu&quot;, function(event)&#123;</span><br><span class="line">        event = EventUtil.getEvent(event);</span><br><span class="line">        EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">        var menu = document.getElementById(&apos;myMenu&apos;);</span><br><span class="line">        menu.style.left = event.clientX + &apos;px&apos;;</span><br><span class="line">        menu.style.top = event.clientY = &apos;px&apos;;</span><br><span class="line">        menu,style.visibility = &quot;visible&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    EventUtil.addHandler(document, &apos;click&apos;, function()&#123;</span><br><span class="line">        document.getElementById(&apos;myMenu&apos;).style.visibility = &apos;hidden&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="beforeunload-页面卸载前-事件"><a href="#beforeunload-页面卸载前-事件" class="headerlink" title="beforeunload(页面卸载前) 事件"></a>beforeunload(页面卸载前) 事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(window, &quot;beforeunload&quot;, function(event)&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    var message = &quot;I&apos;m really going to miss you if you go.&quot;;</span><br><span class="line">    event.returnValue = message;</span><br><span class="line">    return message;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="DOMContentLoaded-IE-9-事件"><a href="#DOMContentLoaded-IE-9-事件" class="headerlink" title="DOMContentLoaded(IE 9+) 事件"></a>DOMContentLoaded(IE 9+) 事件</h4><p>DOMContentLoaded 事件在形成完整的 DOM 树之后就会触发，不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(document, &quot;DOMContentLoaded&quot;, function(event)&#123;</span><br><span class="line">    alert(&apos;Content loaded&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a>readystatechange 事件</h4><p>readyState 属性： uninitialized|loading|loaded|interactive|complete</p>
<h3 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h3><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//一下面的 HTML 代码为例</span><br><span class="line">&lt;ul id=&quot;myLinks&quot;&gt;</span><br><span class="line">    &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt;</span><br><span class="line">    &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt;</span><br><span class="line">    &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var list = document.getElementById(&apos;myLinks&apos;);</span><br><span class="line">EventUtil.addHandler(list, &quot;click&quot;, function(event)&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    var target = EventUtil.getTarget(event);</span><br><span class="line"></span><br><span class="line">    switch(target.id) &#123;</span><br><span class="line">        case &quot;doSomething&quot;:</span><br><span class="line">            document.title = &quot;I changed the document&apos;s title&quot;;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &quot;goSomewhere&quot;:</span><br><span class="line">            location.href = &apos;http://www.google.com&apos;;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &quot;sayHi&quot;:</span><br><span class="line">            alert(&quot;hi&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最适合采用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup、和keypress。虽然 moseover 和 mouseout 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。(因为当鼠标从一个元素移到其子节点时，或者当鼠标移出该元素时，都会触发 mouseout事件。)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/事件/">事件</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/01/DOM2和DOM3/" title="DOM2和DOM3" itemprop="url">DOM2和DOM3</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-05-01T08:18:11.444Z" itemprop="datePublished"> 发表于 2016-05-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="DOM-样式属性和方法"><a href="#DOM-样式属性和方法" class="headerlink" title="DOM 样式属性和方法"></a>DOM 样式属性和方法</h4><p>取得 CSS 属性名和值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var prop, value, i, len;</span><br><span class="line">for (i=0, len=myDiv.style.length; i &lt; len; i++) &#123;</span><br><span class="line">    prop = myDiv.style[i];    //或者 myDiv.style.item(i)</span><br><span class="line">    value = myDiv.style.getPropertyValue(prop);</span><br><span class="line">    alert(prop + &quot;:&quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h4><p>跨浏览器取得样式表对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getStyleSheet(element) &#123;</span><br><span class="line">    return element.sheet || element.styleSheet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取得第一个&lt;link/&gt;元素引入的样式表</span><br><span class="line">var link = document.getElementsByTagName(&quot;link&quot;)[0];</span><br><span class="line">var sheet = getStyleSheet(link);</span><br></pre></td></tr></table></figure>
<h5 id="CSS-规则"><a href="#CSS-规则" class="headerlink" title="CSS 规则"></a>CSS 规则</h5><p>跨浏览器向样式表中添加规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function insertRule(sheet, selectorText, cssText, position) &#123;</span><br><span class="line">    if (sheet.insertRule) &#123;</span><br><span class="line">        sheet.insertRule(selectorText + &quot;&#123;&quot; + cssText + &quot;&#125;&quot;, position);</span><br><span class="line">    &#125; else if (sheet.addRule) &#123;  //兼容 IE</span><br><span class="line">        sheet.addRule(selectorText, cssText, position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insertRule(document.styleSheets[0], &quot;body&quot;, &quot;background-color:silver&quot;, 0);</span><br></pre></td></tr></table></figure>
<h5 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h5><p>跨浏览器删除规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function deleteRule(sheet, index) &#123;</span><br><span class="line">    if (sheet.deleteRule) &#123;</span><br><span class="line">        sheet.deleteRule(index);</span><br><span class="line">    &#125; else if (sheet.removeRule) &#123;</span><br><span class="line">        sheet.removeRule(index);   //兼容 IE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deleteRule(document.styleSheet[0], 0);</span><br></pre></td></tr></table></figure>
<p><strong>与添加规则相似，删除规则也不是实际 Web 开发中常见的做法。 考虑到删除规则可能会影响 CSS 层叠的效果，因此要慎重使用</strong></p>
<h4 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h4><h5 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h5><p>确定浏览器视口大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getViewport() &#123;</span><br><span class="line">    if (document.compatMode == &quot;BackCompat&quot;) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            width: document.body.clientWidth,  // IE</span><br><span class="line">            height: document.body.clientHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            width: document.documentElement.clientWidth,</span><br><span class="line">            height: document.documentElement.clientHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/DOM2/">DOM2</a><a href="/tags/DOM3/">DOM3</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/01/DOM扩展/" title="DOM 扩展" itemprop="url">DOM 扩展</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-05-01T07:33:31.037Z" itemprop="datePublished"> 发表于 2016-05-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><p>跨浏览器遍历某元素的所有子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var i,</span><br><span class="line">    len,</span><br><span class="line">    child = element.firstChild;</span><br><span class="line">while(child != element.lastChild) &#123;</span><br><span class="line">    if (child.nodeType == 1) &#123;</span><br><span class="line">        processChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    child = child.nextSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而使用 Element Traversal(IE 9+) 新增的元素，代码会更简洁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var i,</span><br><span class="line">    len,</span><br><span class="line">    child = element.firstElementChild;</span><br><span class="line">while(child != element.lastElementChild) &#123;</span><br><span class="line">    processChild(child);</span><br><span class="line">    child = child.nextElementSbling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除类名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;bd user disabled&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//删除&quot;user&quot;类</span><br><span class="line"></span><br><span class="line">//首先，取得类名字符串并拆分成数组</span><br><span class="line">var classNames = div.className.split(/\s/);</span><br><span class="line"></span><br><span class="line">//找到要删除的类名</span><br><span class="line">var pos = -1,</span><br><span class="line">    i,</span><br><span class="line">    len;</span><br><span class="line">for (i=0, len=classNames.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (classNames[i] == &quot;user&quot;) &#123;</span><br><span class="line">        pos = i;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除类名</span><br><span class="line">classNames.splice(pos,1);</span><br><span class="line"></span><br><span class="line">//把剩下的类名拼成字符串并重新设置</span><br><span class="line">div.className = classNames.join(&quot; &quot;);</span><br></pre></td></tr></table></figure>
<h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><p>跨浏览器兼容 innerText</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function setInnerText(element, text) &#123;</span><br><span class="line">    if (typeof element.textContent == &quot;string&quot;) &#123;</span><br><span class="line">        element.textContent = text;  //兼容 Firefox</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        element.innerText = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/DOM/">DOM</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/01/DOM/" title="DOM" itemprop="url">DOM</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-05-01T01:58:29.235Z" itemprop="datePublished"> 发表于 2016-05-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h3><h4 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h4><p>确定节点类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (someNode.nodeType == Node.ELEMENT_NODE) &#123;    //在IE中无效</span><br><span class="line">    alert(&quot;Node is an element&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跨浏览器兼容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (someNode.nodeType == 1) &#123;    //适用于所有浏览器</span><br><span class="line">    alert(&quot;Node is an element&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将 NodeList 对象转为数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在 IE8 及之前版本中无效</span><br><span class="line">var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);</span><br></pre></td></tr></table></figure>
<p>跨浏览器兼容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function convertToArray(nodes) &#123;</span><br><span class="line">    var array = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        array = Array.prototype.slice.call(someNode.childNodes,0);  //针对非 IE 浏览器</span><br><span class="line">    &#125; catch (ex) &#123;</span><br><span class="line">        array = new Array();</span><br><span class="line">        for (var i=0, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">            array.push(nodes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (elemeent.tagName == &quot;div&quot;) &#123;  //不能这样比较，很容易出错！</span><br><span class="line">    //在此执行某些操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (elemeent.tagName.toLowerCase() == &quot;div&quot;) &#123;  //这样最好(适用于任何文档)</span><br><span class="line">    //在此执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h5><p>在通过 JavaScript 以编程方式操作 DOM 时，开发人员经常不使用 getAttribute(),而是只使用对象的属性。只用在取得自定义特性值的情况下，才会使用 getAttribute() 方法。</p>
<h4 id="DocumentFragment-类型"><a href="#DocumentFragment-类型" class="headerlink" title="DocumentFragment 类型"></a>DocumentFragment 类型</h4><p>假设想为这个 &lt;\ul id=”myList”&gt;&lt;\/ul&gt; 元素添加3个列表项。如果逐个添加列表项，将会导致浏览器反复渲染新信息。为了避免这个问题，可以像下面这样使用一个文档片段来保存创建的列表项，然后再一次性将他们添加到文档中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line">var ul = document.gtElementById(&quot;myList&quot;);</span><br><span class="line">var li = null;</span><br><span class="line"></span><br><span class="line">for (var i=0; i &lt; 3; i++) &#123;</span><br><span class="line">    li = document.createElement(&quot;li&quot;);</span><br><span class="line">    li.appendChid(document.createTextNode(&quot;Item &quot; + (i+1)));</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>
<h3 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h3><h4 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h4><p>兼容 IE 和早期版本 Safari</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function loadScriptString(code) &#123;</span><br><span class="line">    var script = document.createElement(&quot;script&quot;);</span><br><span class="line">    script.type = &quot;text/javascript&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">        script.appendChild(document.createTextNode(code));</span><br><span class="line">    &#125; catch (ex) &#123;</span><br><span class="line">        script.text = code;</span><br><span class="line">    &#125;</span><br><span class="line">    document.body.appdendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这样执行代码与在全局全局作用域中巴相同的字符串传递给eval()是一样的。</p>
<h4 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h4><p>通用的解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loadStyleString(css) &#123;</span><br><span class="line">    var style = document.createElement(&quot;style&quot;);</span><br><span class="line">    style.type = &quot;text/css&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">        style.appendChild(document.createTextNode(css));</span><br><span class="line">    &#125; catch(ex) &#123;</span><br><span class="line">        style.styleSheet.cssText = css;    //兼容IE</span><br><span class="line">    &#125;</span><br><span class="line">    var head = document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">    head.appendChild(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这个函数的实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadStyleString(&quot;body&#123;background-color:red&#125;&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果专门针对 IE 编写代码，务必小心使用 styleSheet.cssText 属性。在重用同一个&lt;\style&gt;元素并再次设置这个属性时，有可能导致浏览器崩溃。同样，将 cssText 属性设置为空字符串也可能导致浏览器崩溃。</p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/DOM/">DOM</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/30/BOM/" title="BOM" itemprop="url">BOM</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-04-30T09:09:14.735Z" itemprop="datePublished"> 发表于 2016-04-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h3><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><p>款浏览器取得窗口左边和上边的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var leftPos = (typeof window.screenLeft == &quot;number&quot;) ? window.screenLeft : window.screenY;</span><br><span class="line">var topPos = (typeof window.screenTop == &quot;number&quot;) ? window.screenTop : window.screenX;</span><br></pre></td></tr></table></figure>
<p>移动到新位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将窗口移动到屏幕左上角</span><br><span class="line">window.moveTo(0,0);</span><br><span class="line"></span><br><span class="line">//将窗口向下移动到100像素</span><br><span class="line">window.moveBy(0,100);</span><br></pre></td></tr></table></figure>
<h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>取得页面视口的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var pageWidth = window.innerWidth,</span><br><span class="line">    pageHeight = window.innerHeight;</span><br><span class="line"></span><br><span class="line">if (typeof pageWidth != &quot;number&quot;) &#123;</span><br><span class="line">    if (document.compatMode == &quot;CSS1Compat&quot;) &#123;</span><br><span class="line">        pageWidth = document.documentElement.clientWidth;</span><br><span class="line">        pageHeight = document.documentElement.pageHeight;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pageWidth = document.body.clientWidth;</span><br><span class="line">        pageHeight = document.body.pageHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整浏览器窗口的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//调整到 100 x 100</span><br><span class="line">window.resizeTo(100, 100);</span><br><span class="line"></span><br><span class="line">//调整到200 x 150</span><br><span class="line">window.resizeTo(100, 50);</span><br></pre></td></tr></table></figure>
<h4 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h4><h5 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h5><p>设置： height|left|location|menubar|resizable|scrollbars|status|toolbar|top|width|</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(&quot;http://www.google.com&quot;, &quot;wroxWindow&quot;, &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;);</span><br></pre></td></tr></table></figure>
<p>调用 close() 方法还可以关闭新打开的窗口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wroxWin.close();</span><br><span class="line">alert(wroxWin.closed);    //true</span><br></pre></td></tr></table></figure>
<h5 id="弹出窗口屏蔽程序"><a href="#弹出窗口屏蔽程序" class="headerlink" title="弹出窗口屏蔽程序"></a>弹出窗口屏蔽程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var blocked = false;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    var wroxWin = window.open(&quot;http:www.google.com&quot;&quot;, &quot;_blank&quot;);</span><br><span class="line">    if (wroxWin == null) &#123;</span><br><span class="line">        blocked = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (ex) &#123;</span><br><span class="line">    blocked = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (blocked) &#123;</span><br><span class="line">    alert(&quot;The popup was blocked!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//不建议传递字符串</span><br><span class="line">setTimeout (&quot;alert(&apos;hello world&apos;)&quot;, 1000);</span><br><span class="line"></span><br><span class="line">//推荐的调用方式</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    alert(&apos;hello world&apos;);</span><br><span class="line">    &#125;, 1000);</span><br></pre></td></tr></table></figure>
<p>虽然这两种调用方式都没有问题，但由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。<br>第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript 是一个单线程的解释器，因此一定时间内只能执行一段代码。为了要控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimout()的第二个参数告诉 JavaScript 再过多长时间把当前任务到队列中。如果队列是空的，那么添加的代码回立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</p>
<blockquote>
<p>超时调用的代码都是在全局作用域总执行的，因此函数中 this 的值在非严格模式下指向 window 对象，在严格模式下是 undefined。</p>
</blockquote>
<p>间歇调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var num 0;</span><br><span class="line">var max = 10;</span><br><span class="line">var intervalId = null;</span><br><span class="line"></span><br><span class="line">function incrementNumber() &#123;</span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    //如果执行次数达到max设定的值，则取消后续尚未执行的调用</span><br><span class="line">    if (num == max) &#123;</span><br><span class="line">        clearInterval(intervalId);</span><br><span class="line">        alert(&quot;Done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, </span><br><span class="line"></span><br><span class="line">intervalId = setInterval(incrementNumber, 500);</span><br></pre></td></tr></table></figure>
<p>这个模式也可以使用超时调用来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var num 0;</span><br><span class="line">var max = 10;</span><br><span class="line">var intervalId = null;</span><br><span class="line"></span><br><span class="line">function incrementNumber() &#123;</span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    //如果执行次数未达到max设定的值，则设置另一次超时调用</span><br><span class="line">    if (num &lt; max) &#123;</span><br><span class="line">        setTimout(incrementNumber, 500);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;Done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(incrementNumber, 500);</span><br></pre></td></tr></table></figure>
<p>可见，在使用超时调用时，没有必要跟踪超时调用 ID，因为每次执行代码后，如果不在设置另一次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用有可能在前一个间歇调用结束之前启用。而像前面实例中那样使用超时调用，则完全可以避免这一点。所以最好不要使用间歇调用。</p>
<h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><p>确认对话框的典型用法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (confirm(&quot;Are you sure?&quot;)) &#123;</span><br><span class="line">    alert(&quot;I&apos;m so glad you&apos;re sure!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&quot;I&apos;m sorry to hear you&apos;re not sure.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 promet()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result = prompt(&quot;What is your name?&quot;, &quot;&quot;);</span><br><span class="line">if (result !== null) &#123;</span><br><span class="line">    alert(&quot;Welcome, &quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//显示&quot;打印&quot;对话框</span><br><span class="line">window.print();</span><br><span class="line"></span><br><span class="line">//显示&quot;查找&quot;对话框</span><br><span class="line">window.find();</span><br></pre></td></tr></table></figure>
<h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p>属性名： hash|host|hostname|href|pathname|port|protocol|search</p>
<h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getQueryStringArgs()&#123;</span><br><span class="line"></span><br><span class="line">    //取得查询字符串并去掉开头的问号</span><br><span class="line">    var qs = (location.search.length &gt; 0 ? location.search.subString(1) : &quot;&quot;),</span><br><span class="line">        args = &#123;&#125;,</span><br><span class="line">        items = qs.length ? qs.sqlit(&quot;&amp;&quot;) : [],</span><br><span class="line">        item = null,</span><br><span class="line">        name = null,</span><br><span class="line">        value = null,</span><br><span class="line"></span><br><span class="line">        //在 for 循环中使用</span><br><span class="line">        i = 10,</span><br><span class="line">        len = items.length;</span><br><span class="line"></span><br><span class="line">    //逐个将每一项添加到 args 对象中</span><br><span class="line">    for (i=0; i &lt; len; i++) &#123;</span><br><span class="line">        item = items[i].split(&quot;=&quot;);</span><br><span class="line">        name = decodeURIComponent(item[0]);</span><br><span class="line">        value = decodeURIComponent(item[i]);</span><br><span class="line"></span><br><span class="line">        if (name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//下列三行代码的效果完全一样</span><br><span class="line">location.assign(&quot;http://www.google.com&quot;);</span><br><span class="line">window.location(&quot;http://www.google.com&quot;);</span><br><span class="line">location.href(&quot;http://www.google.com&quot;);</span><br><span class="line"></span><br><span class="line">//设置新值来改变URL</span><br><span class="line">//假设初始URL为 http://www.google.com/WileyCDA/</span><br><span class="line"></span><br><span class="line">//将URL修改为&quot;http://www.google.com/WileyCDA/#section1&quot;</span><br><span class="line">location.hash = &quot;#section1&quot;;</span><br><span class="line"></span><br><span class="line">//将URL修改为&quot;http://www.google.com/WileyCDA/?q=javascript&quot;</span><br><span class="line">location.search = &quot;?q=javascript&quot;</span><br><span class="line"></span><br><span class="line">//将URL修改为&quot;http://www.yahoo.com/WileyCDA/&quot;</span><br><span class="line">location.hostname = &quot;www.yahoo.com&quot;</span><br><span class="line"></span><br><span class="line">//将URL修改为&quot;http://www.yahoo.com/mydir&quot;</span><br><span class="line">location.pathname = &quot;mydir&quot;;</span><br><span class="line"></span><br><span class="line">//将URL修改为&quot;http://www.yahoo.com:8080/WileyCDA&quot;</span><br><span class="line">location.port = 8080;</span><br></pre></td></tr></table></figure>
<p>没修改 location 的属性(hash除外)，页面都会以新URL重新加载</p>
<p>当通过上述任何一种方式修改 URL 之后，浏览器的历史纪录中就会生成一条新纪录，因此用户通过单击”后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用 replace() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.replace(&quot;http://www.google.com&quot;);</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/BOM/">BOM</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/30/调试CSS层/" title="调试CSS层" itemprop="url">调试CSS层</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-04-30T05:34:45.480Z" itemprop="datePublished"> 发表于 2016-04-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot; + (~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</span><br></pre></td></tr></table></figure>
<p>[].forEach.call == Array.prototype.forEach.call<br>$$(“*“) == document.querySelectorAll(“*“)</p>
<p>parseInt(“ffffff”, 16) == 16777215</p>
<p>1 // 1 == 2^0<br>100 //4 == 2^2<br>10000 //16 = 2^4<br>1000000000000000000000000 // 16777216 == 2^24</p>
<p>1&lt;&lt;24 == 16777216</p>
<p>Math.random()*(1&lt;&lt;24) == 0 ~ 16777216</p>
<p>var a = 12.34,          //~~a = 12<br>    b = 1231.8754,      //~~b = -1231<br>    c = 3213.000001     //~~c = 3213</p>
<p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.forEach.call(document.querySelectorAll(&quot;*&quot;),function(a)&#123;</span><br><span class="line">    a.style.outline=&quot;1px solid #&quot; + parseInt(Math.random()*16777216).toString(16)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/CSS/">CSS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/CSS/">CSS</a><a href="/tags/调试/">调试</a><a href="/tags/装逼/">装逼</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/30/函数表达式/" title="函数表达式" itemprop="url">函数表达式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-04-30T01:11:25.038Z" itemprop="datePublished"> 发表于 2016-04-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num * arguments.callee(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用 argument.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归函数时，使用 arguments.callee 总比使用函数名更保险。<br>但在严格模式下，不能通过脚本访问 arguments.callee, 访问这个属性会导致错误。不过，可以使用函数表达式来达成相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var factorial = (function f(num)) &#123;</span><br><span class="line">    if (num &lt;= 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        return num * f(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertyName) &#123;</span><br><span class="line">    return function(object1, object2) &#123;</span><br><span class="line">        var value1 = object1[propertyName];</span><br><span class="line">        var value2 = object2[propertyName];</span><br><span class="line"></span><br><span class="line">        if (value1 &lt; value2) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if (value1 &gt; value2) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部函数的代码访问了外部函数中的变量 propertyName。 即使这个内部函数被返回了，而且是在其它地方被调用了，但它仍然可以访问变量propertyName。之所以还能访问这个变量，是因为内部函数的作用域中包含 createComparisonFunction() 的作用域。要彻底搞清楚其中的细节，必须从理解函数被调用的时候都会发生什么入手。<br>当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终位于第二位，外部函数的外部函数的活动对象始终位于第三位，……直至作为作用域终点的全局执行环境。<br>在函数执行过程中，为读取和写入变量的值，就需要在作用域中查找变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1, value2) &#123;</span><br><span class="line">    if (value1 &lt; value2) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (value1 &gt; value2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = compare(5, 10);</span><br></pre></td></tr></table></figure>
<p>以上代码先定义了 compare() 函数， 然后又在全局作用域中调用了它。当调用 compare() 时，会创建一个包含 arguments、value1、value2 的活动对象。全局执行环境(包含 result 和 compare) 在 compare() 执行环境的作用域链中则处于第二位。</p>
<p>后台的每个执行环境都有一个表示变量的对象---变量对象。全局环境的变量对象始终存在，而像 compare() 函数这样的局部环境的变量对象，则只在函数的执行的过程中存在。<br>无论什么时候再函数中访问一个变量时，就会从作用域链中搜索具有响应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。但是，闭包的情况又有所不同。<br>在另一个<br>在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。因此，在 createComparisonFunction() 函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数 createComparisonFunction() 的活动对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var compare = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line">var result = compare(&#123;name: <span class="string">"Nicholas"</span>&#125;, &#123;name: <span class="string">"Greg"</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>在匿名函数从 createComparisonFunction() 中被返回后，它的作用域链被初始化为包含 createComparisonFunction() 函数的活动对象和全局变量对象。这样，匿名函数就可以访问在 createComparisonFunction() 中定义的所有变量。更为重要的是，createComparisonFunction() 函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当 createComparisonFunction() 函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁返回后，createComparisonFunction() 的活动对象才会被销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建函数</span><br><span class="line">var compareNames = createComparisonFunction(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">//调用函数</span><br><span class="line">var result = compareNames(&#123; name: &quot;Nicholas&quot;&#125;, &#123; name, &quot;Greg&quot;&#125;);</span><br><span class="line"></span><br><span class="line">//解除对匿名函数的引用(以便释放内存)</span><br><span class="line">compareNames = null;</span><br></pre></td></tr></table></figure>
<p>首先，创建的比较函数被保存在变量 compareNames 中。而通过将 compareNames 设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其它作用域(除了全局作用域)也都可以安全地销毁了。</p>
<h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for (var i=0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时每个函数都引用着保存变量 i 的同一个变量对象，所以在每个函数内部 i 的值都是10.但是，可以通过创建另一个匿名函数强制让闭包的行为符合预期。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">createFunctions</span></span>()&#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i=0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span>(num)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><p>this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向window。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line">var object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line"></span><br><span class="line">    getNameFunc : <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            <span class="built_in">return</span> this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()());        //<span class="string">"The Window"</span> (在非严格模式下)</span><br></pre></td></tr></table></figure>
<p>每个函数在被调用时都会自动取得这两个特殊变量：this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</p>
<blockquote>
<p>this 和 arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象，必须将该对象的引用保存到另一个闭包能够访问的变量中。</p>
</blockquote>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>如果闭包的作用域链中保存着一个HTML元素，那么久意味着该元素无法被销毁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">assignHandler</span></span>()&#123;</span><br><span class="line">    var element = document.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(element.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个闭包创建了一个循环引用。由于匿名函数保存了一个对 assignHandler() 的活动对象的引用，因此就会导致无法减少 element 的引用数。只要匿名函数存在，element 的引用数至少也是 1，因此它所占用的内存就永远不会被回收。不过，这个问题可以通过稍微改一下代码来解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">assignHandler</span></span>()&#123;</span><br><span class="line">    var element = document.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    var id = element.id;</span><br><span class="line"></span><br><span class="line">    element.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    element = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消除循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。因为闭包会引用闭包包含函数的整个活动对象，而其中包含着 element。即使闭包不直接引用 element，包含函数的活动对象中也仍然会保存引用。因此，有必要把 element 变量设为 null。这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。</p>
<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function outputNumbers(count) &#123;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        for (var i=0; i &lt; count; i++) &#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)();</span><br><span class="line">        alert(i);    //导致一个错误！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>有权访问私有变量和私有函数的公有方法称为<em>特权方法</em>。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyObject</span></span>() &#123;</span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVariable = 10;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">privateFunction</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //特权方法</span><br><span class="line">    this.publicMethod = <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="built_in">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用私有和特权成员，可以隐藏那些不应该直接被修改的数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name) &#123;</span><br><span class="line"></span><br><span class="line">    this.getName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setName = <span class="keyword">function</span>(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(<span class="string">"Nicholas"</span>);</span><br><span class="line">alert(person.getName());        //<span class="string">"Nicholas"</span></span><br><span class="line">person.setName(<span class="string">"Greg"</span>);</span><br><span class="line">alert(person.getName());        //<span class="string">"Greg"</span></span><br></pre></td></tr></table></figure>
<p>在函数中定义特权方法也有缺点，那就是必须使用构造函数模式来达到这个目的。构造函数的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。</p>
<h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><p>通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVariable = 10;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">privateFunction</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    MyObject = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //公有/特权方法</span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="built_in">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)();</span><br></pre></td></tr></table></figure>
<p>这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明Object时使用 var 关键字。初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject 就成了一个全局变量，能够在私有作用域外被访问到。但在严格模式下给未经生命的变量赋值会导致错误。<br>这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    Person = <span class="keyword">function</span>(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person.prototype.setName = <span class="keyword">function</span>(value)&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    var person1 = new Person(<span class="string">"Nicholas"</span>);</span><br><span class="line">    alert(person1.getName());    //<span class="string">"Nicholas"</span></span><br><span class="line">    person1.setName(<span class="string">"Greg"</span>);</span><br><span class="line">    alert(person1.getName());    //<span class="string">"Greg"</span></span><br><span class="line"></span><br><span class="line">    var person2 = new Person(<span class="string">"Michael"</span>);</span><br><span class="line">    alert(person1.getName());    //<span class="string">"Michael"</span></span><br><span class="line">    alert(person2.getName());    //<span class="string">"Michael"</span></span><br></pre></td></tr></table></figure>
<p>在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用 setName() 会影响所有实例。而调用 seName() 或新建一个 Person 实例都会赋予 name 属性一个新值。<br>以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视具体需求而定。</p>
<blockquote>
<p>多查找作用域链中的一个层次，就会在一定程度上影响查找速度。而这正是使用闭包和私有变量的一个明显的不足之处。</p>
</blockquote>
<h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>前面的模式是用于为自定义类型创建私有变量和特权方法的。而模块模式则是为单例创建私有变量和特权方法。所谓单例，值得就是只有一个实例的对象。按照惯例，Javascript是以对象字面量的方式来创建单例对象的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var singleton = &#123;</span><br><span class="line">    name : value,</span><br><span class="line">    method : <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        //这里是方法的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var singleton = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">    var privateVariable = 10;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">privateFunction</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //特权/公有方法和属性</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        publicMethod : <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="built_in">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var application = function()&#123;</span><br><span class="line"></span><br><span class="line">    //私有变量和函数</span><br><span class="line">    var components = new Array();</span><br><span class="line"></span><br><span class="line">    //初始化</span><br><span class="line">    components.push(new BaseComponent());</span><br><span class="line"></span><br><span class="line">    //公共</span><br><span class="line">    return &#123;</span><br><span class="line">        getComponentCount : function()&#123;</span><br><span class="line">            return components.length;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        registerComponent : function(component)&#123;</span><br><span class="line">            if (typeof component == &quot;object&quot;) &#123;</span><br><span class="line">                components.push(component);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>如果必须创建一个对象并以某些数据对其初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 Object 的实例，因为最终要通过一个对象字面量来表示它。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/函数表达式/">函数表达式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/29/继承/" title="继承" itemprop="url">继承</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YLJ77" target="_blank" itemprop="author">YLJ77</a>
		
  <p class="article-time">
    <time datetime="2016-04-29T07:20:00.048Z" itemprop="datePublished"> 发表于 2016-04-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承接口继承只实现方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要依靠原型链来实现的。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="别忘记默认的原型"><a href="#别忘记默认的原型" class="headerlink" title="别忘记默认的原型"></a>别忘记默认的原型</h4><p>所有的函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是搜游自定义类型都会继承toString()、valueOf()、hasOwnProperty()、isPrototypeOf()、propertyIsEnumerable()、toLocalString()、toString()方法的根本原因。</p>
<h4 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h4><p>子类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>()&#123;</span><br><span class="line">    this.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</span><br><span class="line">    this.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承了 SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">//添加新方法</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//重写超类型中的方法</span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());    //<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当通过 SubType 的实例调用 getSuperValue() 时，调用的就是这个重新定义的方法；但通过 SuperType 的实例调用 getSuperValue()时，还会继续调用原来的那个方法。要额外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。<br>在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样就会重写原型链。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>()&#123;</span><br><span class="line">    this.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</span><br><span class="line">    this.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承了 SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">//使用字面量添加新方法，会导致上一行代码无效</span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    geSubValue : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    someOtherMethod : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());    //error!</span><br></pre></td></tr></table></figure>
<p>以上代码展示了刚刚把 SuperType 的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object 的实例，而非 SuperType 的实例，因此我们设想中的原型已经被切断了---SubType 和 SuperType 之间已经没有关系了。</p>
<h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><p>最主要的问题来自包含引用类型值的原型。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>()&#123;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承了SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);        //<span class="string">"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors);        //<span class="string">"red,blue,green,black"</span></span><br></pre></td></tr></table></figure>
<p>原型链的第二个问题是：没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上由于原型中包含引用类型值所带来的问题，实践中会单独使用原型链。</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫<strong>借用构造函数</strong>的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在(将来)新创建的对象上执行构造函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>()&#123;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</span><br><span class="line">    //继承SuperType</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.color);    //<span class="string">"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.color);    //<span class="string">"red,blue,green"</span></span><br></pre></td></tr></table></figure>
<p>“借调”了超类型的构造函数，实际上是在(未来将要)新创建的SubType实例的环境下调用了 SuperType  构造函数。这样一来，就会在新 SubType 对象上执行 SuperType() 函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会有自己的 colors 属性的副本了</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>()&#123;</span><br><span class="line">    //继承了SuperType,同时还传递了参数</span><br><span class="line">    SuperType.call(this,<span class="string">"Nicholas"</span>);</span><br><span class="line"></span><br><span class="line">    //实例属性</span><br><span class="line">    this.age = 29;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.name);        //<span class="string">"Nicholas"</span>;</span><br><span class="line">alert(instance.age);         //29</span><br></pre></td></tr></table></figure>
<p>为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p>
<h4 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h4><p>方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承，有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> SubType(name,age)&#123;</span><br><span class="line">    //继承属性</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承方法</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.Prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(<span class="string">"Nicholas"</span>, 29);</span><br><span class="line">instance1.color.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.color);        //<span class="string">"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();           //<span class="string">"Nicholas"</span></span><br><span class="line">instance1.sayAge();            //29</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(<span class="string">"Greg"</span>, 27);</span><br><span class="line">alert(instance2.color);        //<span class="string">"red,blue,green"</span></span><br><span class="line">instance2.sayName();           //<span class="string">"Greg"</span></span><br><span class="line">instance2.sayAge();            //27</span><br></pre></td></tr></table></figure>
<p>组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof 和 isPrototypeOf() 也能够用于识别组合继承创建的对象。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>ECMAScript5 通过新增 Object.create() 方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = Object.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = Object.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);        //<span class="string">"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
<p>Object.create() 方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = Object.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">"Greg"</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">alert(anotherPerson.name);    //<span class="string">"Greg"</span></span><br></pre></td></tr></table></figure>
<p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类型的情况下，原型式继承是完全可以胜任的。不过，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型式继承紧密相关的一种思路，它与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createAnother(original) &#123;</span><br><span class="line">    var <span class="built_in">clone</span> = object(original);    //通过调用函数创建一个新对象</span><br><span class="line">    clone.sayHi = <span class="function"><span class="title">function</span></span>()&#123;        //以某种方式来增强这个对象</span><br><span class="line">        alert(<span class="string">"hi"</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">clone</span>;                    //返回这个对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anothorPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();    //<span class="string">"hi"</span></span><br></pre></td></tr></table></figure>
<p>新对象不仅具有 person 的所有属性和方法，而且还有自己sayHi()方法<br>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object() 函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<blockquote>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
</blockquote>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> SubType(name,age)&#123;</span><br><span class="line">    SuperTpye.call(this, name);                    //第二次调用 SuperType()</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();               //第一次调用 SuperType()</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一次调用 SuperType 构造函数时，SubType.prototype 会得到两个属性：name 和 colors; 它们都是 SuperType 的实例属性，只不过现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这一次又在新对象上创建了实例属性 name 和 colors。于是，这两个属性就屏蔽了原型中的两个同名属性。<br>好在已经找到了解决这个问题的方法---寄生组合式继承。<br>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> inheritPrototype(subType, superType)&#123;</span><br><span class="line">    var prototype = Object(superType.prototype);        //创建对象</span><br><span class="line">    prototype.constructor = subType;                    //增强对象</span><br><span class="line">    subTye.prototype = prototype;                       //指定对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> SubType(name, age)&#123;</span><br><span class="line">    SuperType.call(this.name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子的高效率体现在它值调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的，多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf()。 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/继承/">继承</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="YLJ77" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/CSS/" title="CSS">CSS<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>9</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/js/" title="js">js<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/DOM/" title="DOM">DOM<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/DOM2/" title="DOM2">DOM2<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/DOM3/" title="DOM3">DOM3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/函数表达式/" title="函数表达式">函数表达式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/事件/" title="事件">事件<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/随机数/" title="随机数">随机数<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/BOM/" title="BOM">BOM<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/调试/" title="调试">调试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/装逼/" title="装逼">装逼<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/对象/" title="对象">对象<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/响应式/" title="响应式">响应式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/媒体查询/" title="媒体查询">媒体查询<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/继承/" title="继承">继承<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://http:YLJ77.github.io" target="_blank" title="lin&#39;s Blog">lin&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m linjie Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/YLJ77" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:linjieyang77@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/by-nc/4.0" class="cc-opacity" target="_blank">
            <img src="/img/cc-by-nc.svg" alt="Creative Commons" />
          </a>
        </div>
    

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="YLJ77">YLJ77</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
